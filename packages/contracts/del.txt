

  Contract: Access Control: Liquity functions with the caller restricted to Liquity contract(s)
    1) "before all" hook in "Contract: Access Control: Liquity functions with the caller restricted to Liquity contract(s)"

  Contract: BorrowerOperations
    Without proxy
      ✔ addColl(): reverts when top-up would leave trove with ICR < MCR (196ms)
      ✔ addColl(): Increases the activePool ETH and raw ether balance by correct amount (97ms)
      ✔ addColl(), active Trove: adds the correct collateral amount to the Trove (111ms)
      ✔ addColl(), active Trove: Trove is in sortedList before and after (104ms)
      ✔ addColl(), active Trove: updates the stake and updates the total stakes (101ms)
      ✔ addColl(), active Trove: applies pending rewards and updates user's L_ETH, L_ANTUSDDebt snapshots (312ms)
      ✔ addColl(), reverts if trove is non-existent or closed (197ms)
      ✔ addColl(): can add collateral in Recovery Mode (114ms)
      ✔ withdrawColl(): reverts when withdrawal would leave trove with ICR < MCR (153ms)
      ✔ withdrawColl(): reverts when calling address does not have active trove (164ms)
      ✔ withdrawColl(): reverts when system is in Recovery Mode (183ms)
      ✔ withdrawColl(): reverts when requested ETH withdrawal is > the trove's collateral (217ms)
      ✔ withdrawColl(): reverts when withdrawal would bring the user's ICR < MCR (227ms)
      ✔ withdrawColl(): reverts if system is in Recovery Mode (150ms)
      ✔ withdrawColl(): doesn’t allow a user to completely withdraw all collateral from their Trove (due to gas compensation) (154ms)
      ✔ withdrawColl(): leaves the Trove active when the user withdraws less than all the collateral (121ms)
      ✔ withdrawColl(): reduces the Trove's collateral by the correct amount (118ms)
      ✔ withdrawColl(): reduces ActivePool ETH and raw ether by correct amount (120ms)
      ✔ withdrawColl(): updates the stake and updates the total stakes (138ms)
      ✔ withdrawColl(): sends the correct amount of ETH to the user (117ms)
      ✔ withdrawColl(): applies pending rewards and updates user's L_ETH, L_ANTUSDDebt snapshots (477ms)
      ✔ withdrawANTUSD(): reverts when withdrawal would leave trove with ICR < MCR (197ms)
      ✔ withdrawANTUSD(): decays a non-zero base rate (470ms)
      ✔ withdrawANTUSD(): reverts if max fee > 100% (302ms)
      ✔ withdrawANTUSD(): reverts if max fee < 0.5% in Normal mode (350ms)
      ✔ withdrawANTUSD(): reverts if fee exceeds max fee percentage (491ms)
      ✔ withdrawANTUSD(): succeeds when fee is less than max fee percentage (667ms)
      ✔ withdrawANTUSD(): doesn't change base rate if it is already zero (645ms)
      ✔ withdrawANTUSD(): lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation (461ms)
      ✔ withdrawANTUSD(): borrower can't grief the baseRate and stop it decaying by issuing debt at higher frequency than the decay granularity (457ms)
      ✔ withdrawANTUSD(): borrowing at non-zero base rate sends ANTUSD fee to LQTY staking contract (544ms)
      ✔ withdrawANTUSD(): borrowing at non-zero base records the (drawn debt + fee) on the Trove struct (560ms)
      ✔ withdrawANTUSD(): Borrowing at non-zero base rate increases the LQTY staking contract ANTUSD fees-per-unit-staked (584ms)
      ✔ withdrawANTUSD(): Borrowing at non-zero base rate sends requested amount to the user (574ms)
      ✔ withdrawANTUSD(): Borrowing at zero base rate changes ANTUSD fees-per-unit-staked (749ms)
      ✔ withdrawANTUSD(): Borrowing at zero base rate sends debt request to user (615ms)
      ✔ withdrawANTUSD(): reverts when calling address does not have active trove (257ms)
      ✔ withdrawANTUSD(): reverts when requested withdrawal amount is zero ANTUSD (262ms)
      ✔ withdrawANTUSD(): reverts when system is in Recovery Mode (376ms)
      ✔ withdrawANTUSD(): reverts when withdrawal would bring the trove's ICR < MCR (230ms)
      ✔ withdrawANTUSD(): reverts when a withdrawal would cause the TCR of the system to fall below the CCR (263ms)
      ✔ withdrawANTUSD(): reverts if system is in Recovery Mode (259ms)
      ✔ withdrawANTUSD(): increases the Trove's ANTUSD debt by the correct amount (164ms)
      ✔ withdrawANTUSD(): increases ANTUSD debt in ActivePool by correct amount (165ms)
      ✔ withdrawANTUSD(): increases user ANTUSDToken balance by correct amount (155ms)
      ✔ repayANTUSD(): reverts when repayment would leave trove with ICR < MCR (237ms)
      ✔ repayANTUSD(): Succeeds when it would leave trove with net debt >= minimum net debt (229ms)
      ✔ repayANTUSD(): reverts when it would leave trove with net debt < minimum net debt (111ms)
      ✔ adjustTrove(): Reverts if repaid amount is greater than current debt (213ms)
      ✔ repayANTUSD(): reverts when calling address does not have active trove (220ms)
      ✔ repayANTUSD(): reverts when attempted repayment is > the debt of the trove (274ms)
      ✔ repayANTUSD(): reduces the Trove's ANTUSD debt by the correct amount (258ms)
      ✔ repayANTUSD(): decreases ANTUSD debt in ActivePool by correct amount (224ms)
      ✔ repayANTUSD(): decreases user ANTUSDToken balance by correct amount (275ms)
      ✔ repayANTUSD(): can repay debt in Recovery Mode (274ms)
      ✔ repayANTUSD(): Reverts if borrower has insufficient ANTUSD balance to cover his debt repayment (224ms)
      ✔ adjustTrove(): reverts when adjustment would leave trove with ICR < MCR (248ms)
      ✔ adjustTrove(): reverts if max fee < 0.5% in Normal mode (190ms)
      ✔ adjustTrove(): allows max fee < 0.5% in Recovery mode (382ms)
      ✔ adjustTrove(): decays a non-zero base rate (688ms)
      ✔ adjustTrove(): doesn't decay a non-zero base rate when user issues 0 debt (488ms)
      ✔ adjustTrove(): doesn't change base rate if it is already zero (317ms)
      ✔ adjustTrove(): lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation (506ms)
      ✔ adjustTrove(): borrower can't grief the baseRate and stop it decaying by issuing debt at higher frequency than the decay granularity (505ms)
      ✔ adjustTrove(): borrowing at non-zero base rate sends ANTUSD fee to LQTY staking contract (477ms)
      ✔ adjustTrove(): borrowing at non-zero base records the (drawn debt + fee) on the Trove struct (573ms)
      ✔ adjustTrove(): Borrowing at non-zero base rate increases the LQTY staking contract ANTUSD fees-per-unit-staked (568ms)
      ✔ adjustTrove(): Borrowing at non-zero base rate sends requested amount to the user (536ms)
      ✔ adjustTrove(): Borrowing at zero base rate changes ANTUSD balance of LQTY staking contract (495ms)
      ✔ adjustTrove(): Borrowing at zero base rate changes LQTY staking contract ANTUSD fees-per-unit-staked (510ms)
      ✔ adjustTrove(): Borrowing at zero base rate sends total requested ANTUSD to the user (474ms)
      ✔ adjustTrove(): reverts when calling address has no active trove (275ms)
      ✔ adjustTrove(): reverts in Recovery Mode when the adjustment would reduce the TCR (415ms)
      ✔ adjustTrove(): collateral withdrawal reverts in Recovery Mode (251ms)
      ✔ adjustTrove(): debt increase that would leave ICR < 150% reverts in Recovery Mode (261ms)
      ✔ adjustTrove(): debt increase that would reduce the ICR reverts in Recovery Mode (325ms)
      ✔ adjustTrove(): A trove with ICR < CCR in Recovery Mode can adjust their trove to ICR > CCR (318ms)
      ✔ adjustTrove(): A trove with ICR > CCR in Recovery Mode can improve their ICR (453ms)
      ✔ adjustTrove(): debt increase in Recovery Mode charges no fee (261ms)
      ✔ adjustTrove(): reverts when change would cause the TCR of the system to fall below the CCR (237ms)
      ✔ adjustTrove(): reverts when ANTUSD repaid is > debt of the trove (257ms)
      ✔ adjustTrove(): reverts when attempted ETH withdrawal is >= the trove's collateral (268ms)
      ✔ adjustTrove(): reverts when change would cause the ICR of the trove to fall below the MCR (295ms)
      ✔ adjustTrove(): With 0 coll change, doesnt change borrower's coll or ActivePool coll (183ms)
      ✔ adjustTrove(): With 0 debt change, doesnt change borrower's debt or ActivePool debt (153ms)
      ✔ adjustTrove(): updates borrower's debt and coll with an increase in both (264ms)
      ✔ adjustTrove(): updates borrower's debt and coll with a decrease in both (253ms)
      ✔ adjustTrove(): updates borrower's  debt and coll with coll increase, debt decrease (241ms)
      ✔ adjustTrove(): updates borrower's debt and coll with coll decrease, debt increase (231ms)
      ✔ adjustTrove(): updates borrower's stake and totalStakes with a coll increase (266ms)
      ✔ adjustTrove(): updates borrower's stake and totalStakes with a coll decrease (289ms)
      ✔ adjustTrove(): changes ANTUSDToken balance by the requested decrease (248ms)
      ✔ adjustTrove(): changes ANTUSDToken balance by the requested increase (255ms)
      ✔ adjustTrove(): Changes the activePool ETH and raw ether balance by the requested decrease (673ms)
      ✔ adjustTrove(): Changes the activePool ETH and raw ether balance by the amount of ETH sent (255ms)
      ✔ adjustTrove(): Changes the ANTUSD debt in ActivePool by requested decrease (250ms)
      ✔ adjustTrove(): Changes the ANTUSD debt in ActivePool by requested increase (293ms)
      ✔ adjustTrove(): new coll = 0 and new debt = 0 is not allowed, as gas compensation still counts toward ICR (265ms)
      ✔ adjustTrove(): Reverts if requested debt increase and amount is zero (180ms)
      ✔ adjustTrove(): Reverts if requested coll withdrawal and ether is sent (236ms)
      ✔ adjustTrove(): Reverts if it’s zero adjustment (136ms)
      ✔ adjustTrove(): Reverts if requested coll withdrawal is greater than trove's collateral (252ms)
      ✔ adjustTrove(): Reverts if borrower has insufficient ANTUSD balance to cover his debt repayment (252ms)
      ✔ Internal _adjustTrove(): reverts when op is a withdrawal and _borrower param is not the msg.sender (253ms)
      ✔ closeTrove(): reverts when it would lower the TCR below CCR (237ms)
      ✔ closeTrove(): reverts when calling address does not have active trove (207ms)
      ✔ closeTrove(): reverts when system is in Recovery Mode (386ms)
      ✔ closeTrove(): reverts when trove is the only one in the system (217ms)
      ✔ closeTrove(): reduces a Trove's collateral to zero (421ms)
      ✔ closeTrove(): reduces a Trove's debt to zero (258ms)
      ✔ closeTrove(): sets Trove's stake to zero (259ms)
      ✔ closeTrove(): zero's the troves reward snapshots (627ms)
      ✔ closeTrove(): sets trove's status to closed and removes it from sorted troves list (277ms)
      ✔ closeTrove(): reduces ActivePool ETH and raw ether by correct amount (357ms)
      ✔ closeTrove(): reduces ActivePool debt by correct amount (316ms)
      ✔ closeTrove(): updates the the total stakes (341ms)
      ✔ closeTrove(): sends the correct amount of ETH to the user (255ms)
      ✔ closeTrove(): subtracts the debt of the closed Trove from the Borrower's ANTUSDToken balance (261ms)
      ✔ closeTrove(): applies pending rewards (793ms)
      ✔ closeTrove(): reverts if borrower has insufficient ANTUSD balance to repay his entire debt (208ms)
      ✔ openTrove(): emits a TroveUpdated event with the correct collateral and debt (523ms)
      ✔ openTrove(): Opens a trove with net debt >= minimum net debt (175ms)
      ✔ openTrove(): reverts if net debt < minimum net debt (238ms)
      ✔ openTrove(): decays a non-zero base rate (567ms)
      ✔ openTrove(): doesn't change base rate if it is already zero (594ms)
      ✔ openTrove(): lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation (549ms)
      ✔ openTrove(): reverts if max fee > 100% (56ms)
      ✔ openTrove(): reverts if max fee < 0.5% in Normal mode (89ms)
      ✔ openTrove(): allows max fee < 0.5% in Recovery Mode (270ms)
      ✔ openTrove(): reverts if fee exceeds max fee percentage (447ms)
      ✔ openTrove(): succeeds when fee is less than max fee percentage (714ms)
      ✔ openTrove(): borrower can't grief the baseRate and stop it decaying by issuing debt at higher frequency than the decay granularity (571ms)
      ✔ openTrove(): borrowing at non-zero base rate sends ANTUSD fee to LQTY staking contract (475ms)
      ✔ openTrove(): borrowing at non-zero base records the (drawn debt + fee  + liq. reserve) on the Trove struct (476ms)
      ✔ openTrove(): Borrowing at non-zero base rate increases the LQTY staking contract ANTUSD fees-per-unit-staked (470ms)
      ✔ openTrove(): Borrowing at non-zero base rate sends requested amount to the user (643ms)
      ✔ openTrove(): Borrowing at zero base rate changes the LQTY staking contract ANTUSD fees-per-unit-staked (372ms)
      ✔ openTrove(): Borrowing at zero base rate charges minimum fee (374ms)
      ✔ openTrove(): reverts when system is in Recovery Mode and ICR < CCR (275ms)
      ✔ openTrove(): reverts when trove ICR < MCR (330ms)
      ✔ openTrove(): reverts when opening the trove would cause the TCR of the system to fall below the CCR (154ms)
      ✔ openTrove(): reverts if trove is already active (386ms)
      ✔ openTrove(): Can open a trove with ICR >= CCR when system is in Recovery Mode (325ms)
      ✔ openTrove(): Reverts opening a trove with min debt when system is in Recovery Mode (240ms)
      ✔ openTrove(): creates a new Trove and assigns the correct collateral and debt amount (100ms)
      ✔ openTrove(): adds Trove owner to TroveOwners array (122ms)
      ✔ openTrove(): creates a stake and adds it to total stakes (122ms)
      ✔ openTrove(): inserts Trove to Sorted Troves list (304ms)
      ✔ openTrove(): Increases the activePool ETH and raw ether balance by correct amount (140ms)
      ✔ openTrove(): records up-to-date initial snapshots of L_ETH and L_ANTUSDDebt (326ms)
      ✔ openTrove(): allows a user to open a Trove, then close it, then re-open it (420ms)
      ✔ openTrove(): increases the Trove's ANTUSD debt by the correct amount (133ms)
      ✔ openTrove(): increases ANTUSD debt in ActivePool by the debt of the trove (124ms)
      ✔ openTrove(): increases user ANTUSDToken balance by correct amount (95ms)
      ✔ getCompositeDebt(): returns debt + gas comp
      getNewICRFromTroveChange() returns the correct ICR
        ✔ collChange = 0, debtChange = 0
        ✔ collChange = 0, debtChange is positive
        ✔ collChange = 0, debtChange is negative
        ✔ collChange is positive, debtChange is 0
        ✔ collChange is negative, debtChange is 0
        ✔ collChange is negative, debtChange is negative
        ✔ collChange is positive, debtChange is positive
        ✔ collChange is positive, debtChange is negative
        ✔ collChange is negative, debtChange is positive
      getNewTCRFromTroveChange() returns the correct TCR
        ✔ collChange = 0, debtChange = 0 (274ms)
        ✔ collChange = 0, debtChange is positive (271ms)
        ✔ collChange = 0, debtChange is negative (270ms)
        ✔ collChange is positive, debtChange is 0 (307ms)
        ✔ collChange is negative, debtChange is 0 (316ms)
        ✔ collChange is negative, debtChange is negative (298ms)
        ✔ collChange is positive, debtChange is positive (289ms)
        ✔ collChange is positive, debtChange is negative (232ms)
        ✔ collChange is negative, debtChange is positive (304ms)

  Contract: CollSurplusPool
    ✔ CollSurplusPool::getETH(): Returns the ETH balance of the CollSurplusPool after redemption (529ms)
    ✔ CollSurplusPool: claimColl(): Reverts if caller is not Borrower Operations
    ✔ CollSurplusPool: claimColl(): Reverts if nothing to claim
    ✔ CollSurplusPool: reverts trying to send ETH to it
    ✔ CollSurplusPool: accountSurplus: reverts if caller is not Trove Manager

  Contract: Deployment script - Sets correct contract addresses dependencies after deployment
    ✔ Sets the correct PriceFeed address in TroveManager
    2) Sets the correct ANTUSDToken address in TroveManager
    ✔ Sets the correct SortedTroves address in TroveManager
    ✔ Sets the correct BorrowerOperations address in TroveManager
    ✔ Sets the correct ActivePool address in TroveManager
    ✔ Sets the correct DefaultPool address in TroveManager
    ✔ Sets the correct StabilityPool address in TroveManager
    ✔ Sets the correct LQTYStaking address in TroveManager
    ✔ Sets the correct StabilityPool address in ActivePool
    ✔ Sets the correct DefaultPool address in ActivePool
    ✔ Sets the correct BorrowerOperations address in ActivePool
    ✔ Sets the correct TroveManager address in ActivePool
    ✔ Sets the correct ActivePool address in StabilityPool
    ✔ Sets the correct BorrowerOperations address in StabilityPool
    3) Sets the correct ANTUSDToken address in StabilityPool
    ✔ Sets the correct TroveManager address in StabilityPool
    ✔ Sets the correct TroveManager address in DefaultPool
    ✔ Sets the correct ActivePool address in DefaultPool
    ✔ Sets the correct TroveManager address in SortedTroves
    ✔ Sets the correct BorrowerOperations address in SortedTroves
    ✔ Sets the correct TroveManager address in BorrowerOperations
    ✔ Sets the correct PriceFeed address in BorrowerOperations
    ✔ Sets the correct SortedTroves address in BorrowerOperations
    ✔ Sets the correct ActivePool address in BorrowerOperations
    ✔ Sets the correct DefaultPool address in BorrowerOperations
    ✔ Sets the correct LQTYStaking address in BorrowerOperations
    ✔ Sets the correct LQTYToken address in LQTYStaking
    ✔ Sets the correct ActivePool address in LQTYStaking
    4) Sets the correct ActivePool address in LQTYStaking
    ✔ Sets the correct ActivePool address in LQTYStaking
    ✔ Sets the correct BorrowerOperations address in LQTYStaking
    ✔ Sets the correct CommunityIssuance address in LQTYToken
    ✔ Sets the correct LQTYStaking address in LQTYToken
    ✔ Sets the correct LockupContractFactory address in LQTYToken
    ✔ Sets the correct LQTYToken address in LockupContractFactory
    ✔ Sets the correct LQTYToken address in CommunityIssuance
    ✔ Sets the correct StabilityPool address in CommunityIssuance

  Contract: Fee arithmetic tests
    ✔ minutesPassedSinceLastFeeOp(): returns minutes passed for no time increase
    ✔ minutesPassedSinceLastFeeOp(): returns minutes passed between time of last fee operation and current block.timestamp, rounded down to nearest minutes (483ms)
    ✔ decayBaseRateFromBorrowing(): returns the initial base rate for no time increase
    ✔ decayBaseRateFromBorrowing(): returns the initial base rate for less than one minute passed  (211ms)
    ✔ decayBaseRateFromBorrowing(): returns correctly decayed base rate, for various durations. Initial baseRate = 0.01 (1675ms)
    ✔ decayBaseRateFromBorrowing(): returns correctly decayed base rate, for various durations. Initial baseRate = 0.1 (1641ms)
    ✔ decayBaseRateFromBorrowing(): returns correctly decayed base rate, for various durations. Initial baseRate = 0.34539284 (1816ms)
    ✔ decayBaseRateFromBorrowing(): returns correctly decayed base rate, for various durations. Initial baseRate = 0.9976 (1675ms)
    Basic exponentiation
      ✔ decPow(): for exponent = 0, returns 1, regardless of base
      ✔ decPow(): for exponent = 1, returns base, regardless of base (80ms)
      ✔ decPow(): for base = 0, returns 0 for any exponent other than 0 (81ms)
      ✔ decPow(): for base = 1, returns 1 for any exponent (116ms)
      ✔ decPow(): for exponent = 2, returns the square of the base (42ms)
      ✔ decPow(): correct output for various bases and exponents (272ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = 7776000 (seconds in three months) (3539ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = 2592000 (seconds in one month) (3401ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = 43200 (minutes in one month) (2138ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = 525600 (minutes in one year) (2266ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = 2628000 (minutes in five years) (2503ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = minutes in ten years (2479ms)
      ✔ decPow(): abs. error < 1e-9 for exponent = minutes in one hundred years (2469ms)
      - decPow(): overflow test: doesn't overflow for exponent = minutes in 1000 years

  Contract: Gas compensation tests
    ✔ _getCollGasCompensation(): returns the 0.5% of collaterall if it is < $10 in value
    ✔ _getCollGasCompensation(): returns 0.5% of collaterall when 0.5% of collateral < $10 in value
    ✔ getCollGasCompensation(): returns 0.5% of collaterall when 0.5% of collateral = $10 in value
    ✔ getCollGasCompensation(): returns 0.5% of collaterall when 0.5% of collateral = $10 in value
    ✔ _getCompositeDebt(): returns (debt + 50) when collateral < $10 in value
    ✔ getCompositeDebt(): returns (debt + 50) collateral = $10 in value
    ✔ getCompositeDebt(): returns (debt + 50) when 0.5% of collateral > $10 in value
    ✔ getCurrentICR(): Incorporates virtual debt, and returns the correct ICR for new troves (579ms)
    ✔ Gas compensation from pool-offset liquidations. All collateral paid as compensation (681ms)
    ✔ gas compensation from pool-offset liquidations: 0.5% collateral < $10 in value. Compensates $10 worth of collateral, liquidates the remainder (609ms)
    ✔ gas compensation from pool-offset liquidations: 0.5% collateral > $10 in value. Compensates 0.5% of  collateral, liquidates the remainder (887ms)
    ✔ Gas compensation from pool-offset liquidations. Liquidation event emits the correct gas compensation and total liquidated coll and debt (606ms)
    ✔ gas compensation from pool-offset liquidations. Liquidation event emits the correct gas compensation and total liquidated coll and debt (639ms)
    ✔ gas compensation from pool-offset liquidations: 0.5% collateral > $10 in value. Liquidation event emits the correct gas compensation and total liquidated coll and debt (640ms)
    ✔ liquidateTroves(): full offset.  Compensates the correct amount, and liquidates the remainder (851ms)
    ✔ liquidateTroves(): full redistribution. Compensates the correct amount, and liquidates the remainder (529ms)
    ✔ liquidateTroves(): full offset. Liquidation event emits the correct gas compensation and total liquidated coll and debt (757ms)
    ✔ liquidateTroves(): full redistribution. Liquidation event emits the correct gas compensation and total liquidated coll and debt (716ms)
    ✔ Trove ordering: same collateral, decreasing debt. Price successively increases. Troves should maintain ordering by ICR (861ms)
    ✔ Trove ordering: increasing collateral, constant debt. Price successively increases. Troves should maintain ordering by ICR (1995ms)
    ✔ Trove ordering: Constant raw collateral ratio (excluding virtual debt). Price successively increases. Troves should maintain ordering by ICR (1469ms)

  Contract: LQTY Token
    ✔ balanceOf(): gets the balance of the account (41ms)
    ✔ totalSupply(): gets the total supply
    ✔ name(): returns the token's name
    ✔ symbol(): returns the token's symbol
    ✔ version(): returns the token contract's version
    ✔ decimal(): returns the number of decimal digits used
    ✔ allowance(): returns an account's spending allowance for another account's balance (46ms)
    ✔ approve(): approves an account to spend the specified ammount (39ms)
    ✔ approve(): reverts when spender param is address(0)
    ✔ approve(): reverts when owner param is address(0)
    ✔ transferFrom(): successfully transfers from an account which it is approved to transfer from (73ms)
    ✔ transfer(): increases the recipient's balance by the correct amount
    ✔ transfer(): reverts when amount exceeds sender's balance (51ms)
    ✔ transfer(): transfer to a blacklisted address reverts (98ms)
    ✔ transfer(): transfer to or from the zero-address reverts (38ms)
    ✔ mint(): issues correct amount of tokens to the given address
    ✔ mint(): reverts when beneficiary is address(0)
    ✔ increaseAllowance(): increases an account's allowance by the correct amount
    ✔ decreaseAllowance(): decreases an account's allowance by the correct amount
    ✔ sendToLQTYStaking(): changes balances of LQTYStaking and calling account by the correct amounts
    ✔ Initializes PERMIT_TYPEHASH correctly
    ✔ Initializes DOMAIN_SEPARATOR correctly
    ✔ Initial nonce for a given address is 0
    5) permit(): permits and emits an Approval event (replay protected)
    ✔ permit(): fails with expired deadline (52ms)
    ✔ permit(): fails with the wrong signature

  Contract: HintHelpers
    ✔ setup: makes accounts with nominal ICRs increasing by 1% consecutively (45ms)
    ✔ getApproxHint(): returns the address of a Trove within sqrt(length) positions of the correct insert position (595ms)
    ✔ getApproxHint(): returns the head of the list if the CR is the max uint256 value (198ms)
    ✔ getApproxHint(): returns the tail of the list if the CR is lower than ICR of any Trove (178ms)
    ✔ computeNominalCR()

  Contract: Deploying and funding One Year Lockup Contracts
    Deploying LCs
      ✔ LQTY Deployer can deploy LCs through the Factory
      ✔ Anyone can deploy LCs through the Factory
      ✔ LQTY Deployer can deploy LCs directly
      ✔ Anyone can deploy LCs directly
      ✔ LC deployment stores the beneficiary's address in the LC (83ms)
      ✔ LC deployment through the Factory registers the LC in the Factory (41ms)
      ✔ LC deployment through the Factory records the LC contract address and deployer as a k-v pair in the Factory (41ms)
      ✔ LC deployment through the Factory sets the unlockTime in the LC (52ms)
      ✔ Direct deployment of LC sets the unlockTime in the LC
      ✔ LC deployment through the Factory reverts when the unlockTime is < 1 year from system deployment
      ✔ Direct deployment of LC reverts when the unlockTime is < 1 year from system deployment
    Funding LCs
      ✔ LQTY transfer from LQTY deployer to their deployed LC increases the LQTY balance of the LC (91ms)
      ✔ LQTY Multisig can transfer LQTY to LCs deployed through the factory by anyone (123ms)
    Withdrawal attempts on funded, inactive LCs immediately after funding
      ✔ Beneficiary can't withdraw from their funded LC (141ms)
      ✔ LQTY multisig can't withraw from a LC which it funded (99ms)
      ✔ No one can withraw from a LC (69ms)

  Contract: Deploying the LQTY contracts: LCF, CI, LQTYStaking, and LQTYToken 
    CommunityIssuance deployment
      ✔ Stores the deployer's address
    LQTYStaking deployment
      ✔ Stores the deployer's address
    LQTYToken deployment
      ✔ Stores the multisig's address
      ✔ Stores the CommunityIssuance address
      ✔ Stores the LockupContractFactory address
      ✔ Mints the correct LQTY amount to the multisig's address: (64.66 million)
      ✔ Mints the correct LQTY amount to the CommunityIssuance contract address: 32 million
      ✔ Mints the correct LQTY amount to the bountyAddress EOA: 2 million
      ✔ Mints the correct LQTY amount to the lpRewardsAddress EOA: 1.33 million
    Community Issuance deployment
      ✔ Stores the deployer's address
      ✔ Has a supply cap of 32 million
      ✔ Liquity AG can set addresses if CI's LQTY balance is equal or greater than 32 million  (98ms)
      ✔ Liquity AG can't set addresses if CI's LQTY balance is < 32 million  (120ms)
    Connecting LQTYToken to LCF, CI and LQTYStaking
      ✔ sets the correct LQTYToken address in LQTYStaking (142ms)
      ✔ sets the correct LQTYToken address in LockupContractFactory
      ✔ sets the correct LQTYToken address in CommunityIssuance (107ms)

  Contract: During the initial lockup period
    LQTY transfer during first year after LQTY deployment
      ✔ Liquity multisig can not transfer LQTY to a LC that was deployed directly (46ms)
      ✔ Liquity multisig can not transfer to an EOA or Liquity system contracts (242ms)
      ✔ Liquity multisig can not approve any EOA or Liquity system contract to spend their LQTY (252ms)
      ✔ Liquity multisig can not increaseAllowance for any EOA or Liquity contract (202ms)
      ✔ Liquity multisig can not decreaseAllowance for any EOA or Liquity contract (255ms)
      ✔ Liquity multisig can not be the sender in a transferFrom() call
      ✔ Liquity multisig can not stake their LQTY in the staking contract
      ✔ Anyone (other than Liquity multisig) can transfer LQTY to LCs deployed by anyone through the Factory (102ms)
      ✔ Anyone (other than Liquity multisig) can transfer LQTY to LCs deployed by anyone directly (100ms)
      ✔ Anyone (other than liquity multisig) can transfer to an EOA
      ✔ Anyone (other than liquity multisig) can approve any EOA or to spend their LQTY
      ✔ Anyone (other than liquity multisig) can increaseAllowance for any EOA or Liquity contract (169ms)
      ✔ Anyone (other than liquity multisig) can decreaseAllowance for any EOA or Liquity contract (222ms)
      ✔ Anyone (other than liquity multisig) can be the sender in a transferFrom() call (54ms)
      ✔ Anyone (other than liquity AG) can stake their LQTY in the staking contract
    Lockup Contract Factory negative tests
      ✔ deployLockupContract(): reverts when LQTY token address is not set (44ms)
    Transferring LQTY to LCs
      ✔ Liquity multisig can transfer LQTY (vesting) to lockup contracts they deployed (80ms)
      ✔ Liquity multisig can transfer LQTY to lockup contracts deployed by anyone (83ms)
    Deploying new LCs
      ✔ LQTY Deployer can deploy LCs through the Factory
      ✔ Liquity multisig can deploy LCs through the Factory (38ms)
      ✔ Anyone can deploy LCs through the Factory
      ✔ LQTY Deployer can deploy LCs directly
      ✔ Liquity multisig can deploy LCs directly
      ✔ Anyone can deploy LCs directly
      ✔ Anyone can deploy LCs with unlockTime = one year from deployment, directly and through factory (62ms)
      ✔ Anyone can deploy LCs with unlockTime > one year from deployment, directly and through factory (70ms)
      ✔ No one can deploy LCs with unlockTime < one year from deployment, directly or through factory (68ms)
      Withdrawal Attempts on LCs before unlockTime has passed 
        ✔ Liquity multisig can't withdraw from a funded LC they deployed for another beneficiary through the Factory before the unlockTime
        ✔ Liquity multisig can't withdraw from a funded LC that someone else deployed before the unlockTime
        ✔ Beneficiary can't withdraw from their funded LC before the unlockTime (113ms)
        ✔ No one can withdraw from a beneficiary's funded LC before the unlockTime (213ms)

  Contract: After the initial lockup period has passed
    Deploying new LCs
      ✔ LQTY Deployer can deploy new LCs
      ✔ Anyone can deploy new LCs
      ✔ Anyone can deploy new LCs with unlockTime in the past (49ms)
      ✔ Anyone can deploy new LCs with unlockTime in the future
    Beneficiary withdrawal from initial LC
      ✔ A beneficiary can withdraw their full entitlement from their LC (73ms)
      ✔ A beneficiary on a vesting schedule can withdraw their total vested amount from their LC (94ms)
      ✔ Beneficiaries can withraw full LQTY balance of LC if it has increased since lockup period ended (147ms)
    Withdrawal attempts from LCs by non-beneficiaries
      ✔ LQTY Multisig can't withdraw from a LC they deployed through the Factory
      ✔ LQTY Multisig can't withdraw from a LC that someone else deployed
      ✔ Non-beneficiaries cannot withdraw from a LC (176ms)
    Transferring LQTY
      ✔ LQTY multisig can transfer LQTY to LCs they deployed (136ms)
      ✔ LQTY multisig can transfer tokens to LCs deployed by anyone (50ms)
      ✔ LQTY multisig can transfer LQTY directly to any externally owned account (47ms)
      ✔ Anyone can transfer LQTY to LCs deployed by anyone (60ms)
      ✔ Anyone can transfer to an EOA (44ms)
      ✔ Anyone can approve any EOA to spend their LQTY
      ✔ Anyone can increaseAllowance for any EOA or Liquity contract (251ms)
      ✔ Anyone can decreaseAllowance for any EOA or Liquity contract (598ms)
      ✔ Anyone can be the sender in a transferFrom() call (52ms)
      ✔ Anyone can stake their LQTY in the staking contract
    Withdrawal Attempts on new LCs before unlockTime has passed
      ✔ LQTY Deployer can't withdraw from a funded LC they deployed for another beneficiary through the Factory, before the unlockTime
      ✔ LQTY Deployer can't withdraw from a funded LC that someone else deployed, before the unlockTime (64ms)
      ✔ Beneficiary can't withdraw from their funded LC, before the unlockTime
      ✔ No one can withdraw from a beneficiary's funded LC, before the unlockTime (112ms)
    Withdrawals from new LCs after unlockTime has passed
      ✔ LQTY Deployer can't withdraw from a funded LC they deployed for another beneficiary through the Factory, after the unlockTime
      ✔ LQTY multisig can't withdraw from a funded LC when they are not the beneficiary, after the unlockTime
      ✔ Beneficiary can withdraw from their funded LC, after the unlockTime (46ms)
      ✔ Non-beneficiaries can't withdraw from a beneficiary's funded LC, after the unlockTime (91ms)

  Contract: LiquityMath
    ✔ max works if a > b
    ✔ max works if a = b
    ✔ max works if a < b

  Contract: LiquitySafeMath128Tester
    ✔ add(): reverts if overflows
    ✔ sub(): reverts if underflows

  Contract: LQTY community issuance arithmetic tests
issuance fraction before: 221529352078264
issuance fraction after: 221529352078264
    ✔ getCumulativeIssuanceFraction(): fraction doesn't increase if less than a minute has passed (53ms)
    ✔ Cumulative issuance fraction is 0.0000013 after a minute
    ✔ Cumulative issuance fraction is 0.000079 after an hour
    ✔ Cumulative issuance fraction is 0.0019 after a day
    ✔ Cumulative issuance fraction is 0.013 after a week
    ✔ Cumulative issuance fraction is 0.055 after a month
    ✔ Cumulative issuance fraction is 0.16 after 3 months
    ✔ Cumulative issuance fraction is 0.29 after 6 months
    ✔ Cumulative issuance fraction is 0.5 after a year
    ✔ Cumulative issuance fraction is 0.75 after 2 years
    ✔ Cumulative issuance fraction is 0.875 after 3 years
    ✔ Cumulative issuance fraction is 0.9375 after 4 years
    ✔ Cumulative issuance fraction is 0.999 after 10 years
    ✔ Cumulative issuance fraction is 0.999999 after 20 years
    ✔ Cumulative issuance fraction is 0.999999999 after 30 years
    ✔ Total LQTY tokens issued is 42.20 after a minute
    ✔ Total LQTY tokens issued is 2,531.94 after an hour
    ✔ Total LQTY tokens issued is 60,711.40 after a day
    ✔ Total LQTY tokens issued is 422,568.60 after a week
    ✔ Total LQTY tokens issued is 1,772,113.21 after a month
    ✔ Total LQTY tokens issued is 5,027,363.22 after 3 months (49ms)
    ✔ Total LQTY tokens issued is 9,264,902.04 after 6 months
    ✔ Total LQTY tokens issued is 16,000,000 after a year (42ms)
    ✔ Total LQTY tokens issued is 24,000,000 after 2 years (42ms)
    ✔ Total LQTY tokens issued is 28,000,000 after 3 years (45ms)
    ✔ Total LQTY tokens issued is 30,000,000 after 4 years (42ms)
    ✔ Total LQTY tokens issued is 31,968,750 after 10 years
    ✔ Total LQTY tokens issued is 31,999,969.48 after 20 years
    ✔ Total LQTY tokens issued is 31,999,999.97 after 30 years (48ms)
    - Frequent token issuance: issuance event every year, for 30 years
    - Frequent token issuance: issuance event every day, for 30 years
    - Frequent token issuance: issuance event every minute, for 1 month
    - Frequent token issuance: issuance event every minute, for 1 year

  Contract: LQTYStaking revenue share tests
    ✔ stake(): reverts if amount is zero
    ✔ ETH fee per LQTY staked increases when a redemption fee is triggered and totalStakes > 0 (809ms)
    ✔ ETH fee per LQTY staked doesn't change when a redemption fee is triggered and totalStakes == 0 (849ms)
    ✔ ANTUSD fee per LQTY staked increases when a redemption fee is triggered and totalStakes > 0 (1167ms)
    ✔ ANTUSD fee per LQTY staked doesn't change when a redemption fee is triggered and totalStakes == 0 (1084ms)
    ✔ LQTY Staking: A single staker earns all ETH and LQTY fees that occur (1330ms)
    ✔ stake(): Top-up sends out all accumulated ETH and ANTUSD gains to the staker (1327ms)
    ✔ getPendingETHGain(): Returns the staker's correct pending ETH gain (1115ms)
    ✔ getPendingANTUSDGain(): Returns the staker's correct pending ANTUSD gain (1217ms)
    ✔ LQTY Staking: Multiple stakers earn the correct share of all ETH and LQTY fees, based on their stake size (2052ms)
    ✔ receive(): reverts when it receives ETH from an address that is not the Active Pool
    ✔ unstake(): reverts if user has no stake
    ✔ Test requireCallerIsTroveManager

  Contract: ANTUSDToken
    Basic token functions, without Proxy
      ✔ balanceOf(): gets the balance of the account
      ✔ totalSupply(): gets the total supply
      6) name(): returns the token's name
      7) symbol(): returns the token's symbol
      ✔ decimal(): returns the number of decimal digits used
      ✔ allowance(): returns an account's spending allowance for another account's balance
      ✔ approve(): approves an account to spend the specified amount
      ✔ approve(): reverts when spender param is address(0)
      ✔ approve(): reverts when owner param is address(0)
      ✔ transferFrom(): successfully transfers from an account which is it approved to transfer from (43ms)
      ✔ transfer(): increases the recipient's balance by the correct amount
      ✔ transfer(): reverts if amount exceeds sender's balance
      ✔ transfer(): transferring to a blacklisted address reverts (61ms)
      ✔ increaseAllowance(): increases an account's allowance by the correct amount
      ✔ mint(): issues correct amount of tokens to the given address
      ✔ burn(): burns correct amount of tokens from the given address
      ✔ sendToPool(): changes balances of Stability pool and user by the correct amounts
      ✔ returnFromPool(): changes balances of Stability pool and user by the correct amounts
      ✔ transfer(): transferring to a blacklisted address reverts (67ms)
      ✔ decreaseAllowance(): decreases allowance by the expected amount
      ✔ decreaseAllowance(): fails trying to decrease more than previously allowed
      ✔ version(): returns the token contract's version
      ✔ Initializes PERMIT_TYPEHASH correctly
      ✔ Initializes DOMAIN_SEPARATOR correctly
      ✔ Initial nonce for a given address is 0
      8) permits and emits an Approval event (replay protected)
      ✔ permits(): fails with expired deadline
      ✔ permits(): fails with the wrong signature
    Basic token functions, with Proxy
      ✔ balanceOf(): gets the balance of the account
      ✔ totalSupply(): gets the total supply
      9) name(): returns the token's name
      10) symbol(): returns the token's symbol
      ✔ decimal(): returns the number of decimal digits used
      ✔ allowance(): returns an account's spending allowance for another account's balance
      ✔ approve(): approves an account to spend the specified amount
      ✔ transferFrom(): successfully transfers from an account which is it approved to transfer from (46ms)
      ✔ transfer(): increases the recipient's balance by the correct amount
      ✔ transfer(): reverts if amount exceeds sender's balance
      ✔ transfer(): transferring to a blacklisted address reverts (273ms)
      ✔ increaseAllowance(): increases an account's allowance by the correct amount
      ✔ transfer(): transferring to a blacklisted address reverts (129ms)
      ✔ decreaseAllowance(): decreases allowance by the expected amount
      ✔ decreaseAllowance(): fails trying to decrease more than previously allowed (48ms)

  Contract: All Liquity functions with onlyOwner modifier
    TroveManager
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (378ms)
    BorrowerOperations
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (291ms)
    DefaultPool
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (264ms)
    StabilityPool
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (318ms)
    ActivePool
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (159ms)
    SortedTroves
      ✔ setParams(): reverts when called by non-owner, with wrong addresses, or twice (91ms)
    CommunityIssuance
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (61ms)
    LQTYStaking
      ✔ setAddresses(): reverts when called by non-owner, with wrong addresses, or twice (215ms)
    LockupContractFactory
      ✔ setLQTYAddress(): reverts when called by non-owner, with wrong address, or twice (126ms)

  Contract: StabilityPool
    ✔ getETH(): gets the recorded ETH balance
    ✔ getTotalANTUSDDeposits(): gets the recorded ANTUSD balance

  Contract: ActivePool
    ✔ getETH(): gets the recorded ETH balance
    ✔ getANTUSDDebt(): gets the recorded ANTUSD balance
    ✔ increaseANTUSD(): increases the recorded ANTUSD balance by the correct amount
    ✔ decreaseANTUSD(): decreases the recorded ANTUSD balance by the correct amount
    - sendETH(): decreases the recorded ETH balance by the correct amount

  Contract: DefaultPool
    ✔ getETH(): gets the recorded ANTUSD balance
    ✔ getANTUSDDebt(): gets the recorded ANTUSD balance
    ✔ increaseANTUSD(): increases the recorded ANTUSD balance by the correct amount
    ✔ decreaseANTUSD(): decreases the recorded ANTUSD balance by the correct amount
    - sendETHToActivePool(): decreases the recorded ETH balance by the correct amount

  Contract: PriceFeed
    ✔ C1 Chainlink working: fetchPrice should return the correct price, taking into account the number of decimal digits on the aggregator (156ms)
    ✔ C1 Chainlink breaks, Tellor working: fetchPrice should return the correct Tellor price, taking into account Tellor's 6-digit granularity (321ms)
    ✔ C1 chainlinkWorking: Chainlink broken by zero latest roundId, Tellor working: switch to usingChainlinkTellorUntrusted (144ms)
    ✔ C1 chainlinkWorking: Chainlink broken by zero latest roundId, Tellor working: use Tellor price (50ms)
    ✔ C1 chainlinkWorking: Chainlink broken by zero timestamp, Tellor working, switch to usingChainlinkTellorUntrusted (77ms)
    ✔ C1 chainlinkWorking:  Chainlink broken by zero timestamp, Tellor working, return Tellor price (51ms)
    ✔ C1 chainlinkWorking: Chainlink broken by future timestamp, Tellor working, switch to usingChainlinkTellorUntrusted (67ms)
    ✔ C1 chainlinkWorking: Chainlink broken by future timestamp, Tellor working, return Tellor price (140ms)
    ✔ C1 chainlinkWorking: Chainlink broken by negative price, Tellor working,  switch to usingChainlinkTellorUntrusted (142ms)
    ✔ C1 chainlinkWorking: Chainlink broken by negative price, Tellor working, return Tellor price (56ms)
    ✔ C1 chainlinkWorking: Chainlink broken - decimals call reverted, Tellor working, switch to usingChainlinkTellorUntrusted (76ms)
    ✔ C1 chainlinkWorking: Chainlink broken - decimals call reverted, Tellor working, return Tellor price (51ms)
    ✔ C1 chainlinkWorking: Chainlink broken - latest round call reverted, Tellor working, switch to usingChainlinkTellorUntrusted (101ms)
    ✔ C1 chainlinkWorking: latest round call reverted, Tellor working, return the Tellor price (89ms)
    ✔ C1 chainlinkWorking: previous round call reverted, Tellor working, switch to usingChainlinkTellorUntrusted (116ms)
    ✔ C1 chainlinkWorking: previous round call reverted, Tellor working, return Tellor Price (54ms)
    ✔ C1 chainlinkWorking: Chainlink frozen, Tellor working: switch to usingTellorChainlinkFrozen (72ms)
    ✔ C1 chainlinkWorking: Chainlink frozen, Tellor working: return Tellor price (56ms)
    ✔ C1 chainlinkWorking: Chainlink frozen, Tellor frozen: switch to usingTellorChainlinkFrozen (120ms)
    ✔ C1 chainlinkWorking: Chainlink frozen, Tellor frozen: return last good price (63ms)
    ✔ C1 chainlinkWorking: Chainlink times out, Tellor broken by 0 price: switch to usingChainlinkTellorUntrusted (83ms)
    ✔ C1 chainlinkWorking: Chainlink times out, Tellor broken by 0 price: return last good price (107ms)
    ✔ C1 chainlinkWorking: Chainlink is out of date by <3hrs: remain chainlinkWorking (295ms)
    ✔ C1 chainlinkWorking: Chainlink is out of date by <3hrs: return Chainklink price (50ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50%, switch to usingChainlinkTellorUntrusted (72ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50%, return the Tellor price (107ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of 50%, remain chainlinkWorking (80ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of 50%, return the Chainlink price (44ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of <50%, remain chainlinkWorking (115ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of <50%, return Chainlink price (57ms)
    ✔ C1 chainlinkWorking: Chainlink price increase of >100%, switch to usingChainlinkTellorUntrusted (73ms)
    ✔ C1 chainlinkWorking: Chainlink price increase of >100%, return Tellor price (98ms)
    ✔ C1 chainlinkWorking: Chainlink price increase of 100%, remain chainlinkWorking (64ms)
    ✔ C1 chainlinkWorking: Chainlink price increase of 100%, return Chainlink price (49ms)
    ✔ C1 chainlinkWorking: Chainlink price increase of <100%, remain chainlinkWorking (104ms)
    ✔ C1 chainlinkWorking: Chainlink price increase of <100%,  return Chainlink price (63ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor price matches: remain chainlinkWorking (89ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor price matches: return Chainlink price (76ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor price within 5% of Chainlink: remain chainlinkWorking (44ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor price within 5% of Chainlink: return Chainlink price (71ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor live but not within 5% of Chainlink: switch to usingChainlinkTellorUntrusted (96ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor live but not within 5% of Chainlink: return Tellor price (71ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor frozen: switch to usingChainlinkTellorUntrusted (99ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor frozen: return last good price (84ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor is broken by 0 price: switch to bothOracleSuspect (41ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor is broken by 0 price: return last good price (107ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor is broken by 0 timestamp: switch to bothOracleSuspect (68ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor is broken by 0 timestamp: return last good price (65ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor is broken by future timestamp: Pricefeed switches to bothOracleSuspect (63ms)
    ✔ C1 chainlinkWorking: Chainlink price drop of >50% and Tellor is broken by future timestamp: return last good price (81ms)
    ✔ C1 chainlinkWorking: Chainlink is working and Tellor is working - remain on chainlinkWorking (52ms)
    ✔ C1 chainlinkWorking: Chainlink is working and Tellor is working - return Chainlink price (109ms)
    ✔ C1 chainlinkWorking: Chainlink is working and Tellor freezes - remain on chainlinkWorking (89ms)
    ✔ C1 chainlinkWorking: Chainlink is working and Tellor freezes - return Chainlink price (91ms)
    ✔ C1 chainlinkWorking: Chainlink is working and Tellor breaks: switch to usingChainlinkTellorUntrusted (74ms)
    ✔ C1 chainlinkWorking: Chainlink is working and Tellor breaks: return Chainlink price (50ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor breaks by zero price: switch to bothOraclesSuspect (72ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor breaks by zero price: return last good price (101ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor breaks by call reverted: switch to bothOraclesSuspect (65ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor breaks by call reverted: return last good price (72ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor breaks by zero timestamp: switch to bothOraclesSuspect (81ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor breaks by zero timestamp: return last good price (54ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor freezes - remain usingChainlinkTellorUntrusted (86ms)
    ✔ C2 usingTellorChainlinkUntrusted: Tellor freezes - return last good price (97ms)
    ✔ C2 usingTellorChainlinkUntrusted: both Tellor and Chainlink are live and <= 5% price difference - switch to chainlinkWorking (49ms)
    ✔ C2 usingTellorChainlinkUntrusted: both Tellor and Chainlink are live and <= 5% price difference - return Chainlink price (56ms)
    ✔ C2 usingTellorChainlinkUntrusted: both Tellor and Chainlink are live and > 5% price difference - remain usingChainlinkTellorUntrusted (62ms)
    ✔ C2 usingTellorChainlinkUntrusted: both Tellor and Chainlink are live and > 5% price difference - return Tellor price (44ms)
    ✔ C3 bothOraclesUntrusted: both Tellor and Chainlink are live and > 5% price difference remain bothOraclesSuspect (43ms)
    ✔ C3 bothOraclesUntrusted: both Tellor and Chainlink are live and > 5% price difference, return last good price (81ms)
    ✔ C3 bothOraclesUntrusted: both Tellor and Chainlink are live and <= 5% price difference, switch to chainlinkWorking (65ms)
    ✔ C3 bothOraclesUntrusted: both Tellor and Chainlink are live and <= 5% price difference, return Chainlink price (55ms)
    ✔ C4 usingTellorChainlinkFrozen: when both Chainlink and Tellor break, switch to bothOraclesSuspect (59ms)
    ✔ C4 usingTellorChainlinkFrozen: when both Chainlink and Tellor break, return last good price (59ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink breaks and Tellor freezes, switch to usingChainlinkTellorUntrusted (70ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink breaks and Tellor freezes, return last good price (113ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink breaks and Tellor live, switch to usingChainlinkTellorUntrusted (77ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink breaks and Tellor live, return Tellor price (67ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor is live with <5% price difference, switch back to chainlinkWorking (97ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor is live with <5% price difference, return Chainlink current price (65ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor is live with >5% price difference, switch back to usingChainlinkTellorUntrusted (62ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor is live with >5% price difference, return Chainlink current price (71ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor is live with similar price, switch back to chainlinkWorking (51ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor is live with similar price, return Chainlink current price
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor breaks, switch to usingChainlinkTellorUntrusted (89ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink is live and Tellor breaks, return Chainlink current price (62ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink still frozen and Tellor breaks, switch to usingChainlinkTellorUntrusted (65ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink still frozen and Tellor broken, return last good price (74ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink still frozen and Tellor live, remain usingTellorChainlinkFrozen (81ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink still frozen and Tellor live, return Tellor price (132ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink still frozen and Tellor freezes, remain usingTellorChainlinkFrozen (106ms)
    ✔ C4 usingTellorChainlinkFrozen: when Chainlink still frozen and Tellor freezes, return last good price (76ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live and Tellor price >5% - no status change (45ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live and Tellor price >5% - return Chainlink price (92ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live and Tellor price within <5%, switch to chainlinkWorking (41ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, Tellor price not within 5%, return Chainlink price (125ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, <50% price deviation from previous, Tellor price not within 5%, remain on usingChainlinkTellorUntrusted (78ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, <50% price deviation from previous, Tellor price not within 5%, return Chainlink price (63ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, >50% price deviation from previous, Tellor price not within 5%, remain on usingChainlinkTellorUntrusted (69ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, >50% price deviation from previous,  Tellor price not within 5%, return Chainlink price (77ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, <50% price deviation from previous, and Tellor is frozen, remain on usingChainlinkTellorUntrusted (109ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, <50% price deviation from previous, Tellor is frozen, return Chainlink price (135ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, >50% price deviation from previous, Tellor is frozen, remain on usingChainlinkTellorUntrusted (90ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink is live, >50% price deviation from previous, Tellor is frozen, return Chainlink price (83ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink frozen, remain on usingChainlinkTellorUntrusted (81ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink frozen, return last good price (97ms)
    ✔ C5 usingChainlinkTellorUntrusted: when Chainlink breaks too, switch to bothOraclesSuspect (100ms)
    ✔ C5 usingChainlinkTellorUntrusted: Chainlink breaks too, return last good price (76ms)
    PriceFeed internal testing contract
      ✔ fetchPrice before setPrice should return the default price
      ✔ should be able to fetchPrice after setPrice, output of former matching input of latter
    Mainnet PriceFeed setup
      ✔ fetchPrice should fail on contract with no chainlink address set
      ✔ fetchPrice should fail on contract with no tellor address set
      ✔ setAddresses should fail whe called by nonOwner
      ✔ setAddresses should fail after address has already been set (53ms)

  Contract: BorrowerWrappers
    ✔ proxy owner can recover ETH (1407ms)
    ✔ non proxy owner cannot recover ETH (2086ms)
    ✔ claimCollateralAndOpenTrove(): reverts if nothing to claim (1916ms)
    - claimCollateralAndOpenTrove(): without sending any value
    - claimCollateralAndOpenTrove(): sending value in the transaction
    ✔ claimSPRewardsAndRecycle(): only owner can call it (1924ms)
    - claimSPRewardsAndRecycle():
    ✔ claimStakingGainsAndRecycle(): only owner can call it (2539ms)
    ✔ claimStakingGainsAndRecycle(): reverts if user has no trove (3293ms)
    ✔ claimStakingGainsAndRecycle(): with only ETH gain (2819ms)
    ✔ claimStakingGainsAndRecycle(): with only ANTUSD gain (1881ms)
    ✔ claimStakingGainsAndRecycle(): with both ETH and ANTUSD gains (2641ms)

  Contract: SortedTroves
    SortedTroves
      ✔ contains(): returns true for addresses that have opened troves (340ms)
      ✔ contains(): returns false for addresses that have not opened troves (494ms)
      ✔ contains(): returns false for addresses that opened and then closed a trove (504ms)
      ✔ contains(): returns true for addresses that opened, closed and then re-opened a trove (934ms)
      ✔ contains(): returns false when there are no troves in the system
      ✔ contains(): true when list size is 1 and the trove the only one in system (169ms)
      ✔ contains(): false when list size is 1 and trove is not in the system (104ms)
      ✔ getMaxSize(): Returns the maximum list size
      ✔ Finds the correct insert position given two addresses that loosely bound the correct position (860ms)
      - stays ordered after troves with 'infinite' ICR receive a redistribution
    SortedTroves with mock dependencies
      when params are wrongly set
        ✔ setParams(): reverts if size is zero
      when params are properly set
        ✔ insert(): fails if list is full (46ms)
        ✔ insert(): fails if list already contains the node
        ✔ insert(): fails if id is zero
        ✔ insert(): fails if NICR is zero
        ✔ remove(): fails if id is not in the list
        ✔ reInsert(): fails if list doesn’t contain the node
        ✔ reInsert(): fails if new NICR is zero
        ✔ findInsertPosition(): No prevId for hint - ascend list starting from nextId, result is after the tail

  Contract: StabilityPool Scale Factor issue tests
    Scale Factor issue tests
      11) 1. Liquidation succeeds after P reduced to 1
      ✔ 2. New deposits can be made after P reduced to 1 (1006ms)
      ✔ 3. Liquidation succeeds when P == 1 and liquidation has newProductFactor == 1e9 (912ms)
      ✔ 4. Liquidation succeeds when P == 1 and liquidation has newProductFactor > 1e9 (679ms)
      ✔ 5. Depositor have correct depleted stake after deposit at P == 1 and scale changing liq (with newProductFactor == 1e9) (1034865ms)
      ✔ 6. Depositor have correct depleted stake after deposit at P == 1 and scale changing liq (with newProductFactor > 1e9) (792ms)

  Contract: StabilityPool - LQTY Rewards
    LQTY Rewards
      ✔ liquidation < 1 minute after a deposit does not change totalLQTYIssued (267ms)
      ✔ withdrawFromSP(): reward term G does not update when no LQTY is issued (426ms)
      12) withdrawFromSP(): Depositors with equal initial deposit withdraw correct LQTY gain. No liquidations. No front end.
      ✔ withdrawFromSP(): Depositors with varying initial deposit withdraw correct LQTY gain. No liquidations. No front end. (996ms)
      ✔ withdrawFromSP(): Depositors with varying initial deposit withdraw correct LQTY gain. No liquidations. No front end. (1031ms)
      13) withdrawFromSP(): Depositor withdraws correct LQTY gain after serial pool-emptying liquidations. No front-ends.
      ✔ LQTY issuance for a given period is not obtainable if the SP was empty during the period (263ms)
      ✔ withdrawFromSP(): Several deposits of 100 ANTUSD span one scale factor change. Depositors withdraw correct LQTY gains (2747ms)
      14) withdrawFromSP(): Depositors with equal initial deposit withdraw correct LQTY gain. No liquidations. Front ends and kickback rates.
      ✔ withdrawFromSP(): Depositors with varying initial deposit withdraw correct LQTY gain. Front ends and kickback rates (1936ms)
      ✔ withdrawFromSP(): Several deposits of 10k ANTUSD span one scale factor change. Depositors withdraw correct LQTY gains (1325ms)

  Contract: Pool Manager: Sum-Product rounding errors
    - Rounding errors: 100 deposits of 100ANTUSD into SP, then 200 liquidations of 49ANTUSD

  Contract: StabilityPool - Withdrawal of stability deposit - Reward calculations
    Stability Pool Withdrawal
      ✔ withdrawFromSP(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after one liquidation (324ms)
      ✔ withdrawFromSP(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after two identical liquidations (978ms)
      ✔ withdrawFromSP():  Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after three identical liquidations (885ms)
      ✔ withdrawFromSP(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after two liquidations of increasing ANTUSD (635ms)
      ✔ withdrawFromSP(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after three liquidations of increasing ANTUSD (603ms)
      ✔ withdrawFromSP(): Depositors with varying deposits withdraw correct compounded deposit and ETH Gain after two identical liquidations (943ms)
      ✔ withdrawFromSP(): Depositors with varying deposits withdraw correct compounded deposit and ETH Gain after three identical liquidations (742ms)
      ✔ withdrawFromSP(): Depositors with varying deposits withdraw correct compounded deposit and ETH Gain after three varying liquidations (749ms)

      ✔ withdrawFromSP(): A, B, C Deposit -> 2 liquidations -> D deposits -> 1 liquidation. All deposits and liquidations = 100 ANTUSD.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (751ms)
      ✔ withdrawFromSP(): A, B, C Deposit -> 2 liquidations -> D deposits -> 2 liquidations. All deposits and liquidations = 100 ANTUSD.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (917ms)
      ✔ withdrawFromSP(): A, B, C Deposit -> 2 liquidations -> D deposits -> 2 liquidations. Various deposit and liquidation vals.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1382ms)
      ✔ withdrawFromSP(): A, B, C, D deposit -> 2 liquidations -> D withdraws -> 2 liquidations. All deposits and liquidations = 100 ANTUSD.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (985ms)
      ✔ withdrawFromSP(): A, B, C, D deposit -> 2 liquidations -> D withdraws -> 2 liquidations. Various deposit and liquidation vals. A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (984ms)
      ✔ withdrawFromSP(): A, B, D deposit -> 2 liquidations -> C makes deposit -> 1 liquidation -> D withdraws -> 1 liquidation. All deposits: 100 ANTUSD. Liquidations: 100,100,100,50.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1015ms)
      ✔ withdrawFromSP(): Depositor withdraws correct compounded deposit after liquidation empties the pool (755ms)
      ✔ withdrawFromSP(): Pool-emptying liquidation increases epoch by one, resets scaleFactor to 0, and resets P to 1e18 (1434ms)
      ✔ withdrawFromSP(): Depositors withdraw correct compounded deposit after liquidation empties the pool (750ms)
      ✔ withdrawFromSP(): single deposit fully offset. After subsequent liquidations, depositor withdraws 0 deposit and *only* the ETH Gain from one liquidation (763ms)
      ✔ withdrawFromSP(): Depositor withdraws correct compounded deposit after liquidation empties the pool (1387ms)
      ✔ withdrawFromSP(): deposit spans one scale factor change: Single depositor withdraws correct compounded deposit and ETH Gain after one liquidation (608ms)
      ✔ withdrawFromSP(): Several deposits of varying amounts span one scale factor change. Depositors withdraw correct compounded deposit and ETH Gain after one liquidation (1323ms)
      ✔ withdrawFromSP(): deposit spans one scale factor change: Single depositor withdraws correct compounded deposit and ETH Gain after one liquidation (683ms)
      ✔ withdrawFromSP(): Several deposits of varying amounts span one scale factor change. Depositors withdraws correct compounded deposit and ETH Gain after one liquidation (895ms)
alice deposit: 0
      ✔ withdrawFromSP(): Deposit that decreases to less than 1e-9 of it's original value is reduced to 0 (340ms)
      ✔ withdrawFromSP(): Several deposits of 10000 ANTUSD span one scale factor change. Depositors withdraws correct compounded deposit and ETH Gain after one liquidation (1043ms)
      ✔ withdrawFromSP(): 2 depositors can withdraw after each receiving half of a pool-emptying liquidation (1045ms)
      ✔ withdrawFromSP(): Depositor's ETH gain stops increasing after two scale changes (1108ms)
      ✔ withdrawFromSP(): Large liquidated coll/debt, deposits and ETH price (583ms)
      ✔ withdrawFromSP(): Small liquidated coll/debt, large deposits and ETH price (484ms)

  Contract: StabilityPool - Withdrawal of stability deposit - Reward calculations
    Stability Pool Withdrawal
      ✔ withdrawETHGainToTrove(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after one liquidation (1012ms)
      ✔ withdrawETHGainToTrove(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after two identical liquidations (1013ms)
      ✔ withdrawETHGainToTrove():  Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after three identical liquidations (1170ms)
      ✔ withdrawETHGainToTrove(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after two liquidations of increasing ANTUSD (1006ms)
      ✔ withdrawETHGainToTrove(): Depositors with equal initial deposit withdraw correct compounded deposit and ETH Gain after three liquidations of increasing ANTUSD (1127ms)
      ✔ withdrawETHGainToTrove(): Depositors with varying deposits withdraw correct compounded deposit and ETH Gain after two identical liquidations (1001ms)
      ✔ withdrawETHGainToTrove(): Depositors with varying deposits withdraw correct compounded deposit and ETH Gain after three identical liquidations (1161ms)
      ✔ withdrawETHGainToTrove(): Depositors with varying deposits withdraw correct compounded deposit and ETH Gain after three varying liquidations (1134ms)

      ✔ withdrawETHGainToTrove(): A, B, C Deposit -> 2 liquidations -> D deposits -> 1 liquidation. All deposits and liquidations = 100 ANTUSD.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1983ms)
      ✔ withdrawETHGainToTrove(): A, B, C Deposit -> 2 liquidations -> D deposits -> 2 liquidations. All deposits and liquidations = 100 ANTUSD.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1438ms)
      ✔ withdrawETHGainToTrove(): A, B, C Deposit -> 2 liquidations -> D deposits -> 2 liquidations. Various deposit and liquidation vals.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1492ms)
      ✔ withdrawETHGainToTrove(): A, B, C, D deposit -> 2 liquidations -> D withdraws -> 2 liquidations. All deposits and liquidations = 100 ANTUSD.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1500ms)
      ✔ withdrawETHGainToTrove(): A, B, C, D deposit -> 2 liquidations -> D withdraws -> 2 liquidations. Various deposit and liquidation vals. A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1326ms)
      ✔ withdrawETHGainToTrove(): A, B, D deposit -> 2 liquidations -> C makes deposit -> 1 liquidation -> D withdraws -> 1 liquidation. All deposits: 100 ANTUSD. Liquidations: 100,100,100,50.  A, B, C, D withdraw correct ANTUSD deposit and ETH Gain (1411ms)
      ✔ withdrawETHGainToTrove(): Depositor withdraws correct compounded deposit after liquidation empties the pool (1099ms)
      ✔ withdrawETHGainToTrove(): Pool-emptying liquidation increases epoch by one, resets scaleFactor to 0, and resets P to 1e18 (1184ms)
      ✔ withdrawETHGainToTrove(): Depositors withdraw correct compounded deposit after liquidation empties the pool (1377ms)
      ✔ withdrawETHGainToTrove(): single deposit fully offset. After subsequent liquidations, depositor withdraws 0 deposit and *only* the ETH Gain from one liquidation (944ms)
      ✔ withdrawETHGainToTrove(): Depositor withdraws correct compounded deposit after liquidation empties the pool (2209ms)
      ✔ withdrawETHGainToTrove(): deposit spans one scale factor change: Single depositor withdraws correct compounded deposit and ETH Gain after one liquidation (708ms)
      ✔ withdrawETHGainToTrove(): Several deposits of varying amounts span one scale factor change. Depositors withdraw correct compounded deposit and ETH Gain after one liquidation (1090ms)
      ✔ withdrawETHGainToTrove(): deposit spans one scale factor change: Single depositor withdraws correct compounded deposit and ETH Gain after one liquidation (765ms)
      ✔ withdrawETHGainToTrove(): Several deposits of varying amounts span one scale factor change. Depositors withdraws correct compounded deposit and ETH Gain after one liquidation (1104ms)
alice deposit: 0
      ✔ withdrawETHGainToTrove(): Deposit that decreases to less than 1e-9 of it's original value is reduced to 0 (510ms)
      ✔ withdrawETHGainToTrove(): Several deposits of 10000 ANTUSD span one scale factor change. Depositors withdraws correct compounded deposit and ETH Gain after one liquidation (1514ms)
      ✔ withdrawETHGainToTrove(): 2 depositors can withdraw after each receiving half of a pool-emptying liquidation (2069ms)
      ✔ withdrawETHGainToTrove(): Large liquidated coll/debt, deposits and ETH price (578ms)
      ✔ withdrawETHGainToTrove(): Small liquidated coll/debt, large deposits and ETH price (432ms)

  Contract: StabilityPool
    Stability Pool Mechanisms
      ✔ provideToSP(): increases the Stability Pool ANTUSD balance (124ms)
      ✔ provideToSP(): updates the user's deposit record in StabilityPool (204ms)
      ✔ provideToSP(): reduces the user's ANTUSD balance by the correct amount (137ms)
      ✔ provideToSP(): increases totalANTUSDDeposits by correct amount (113ms)
      ✔ provideToSP(): Correctly updates user snapshots of accumulated rewards per unit staked (557ms)
      ✔ provideToSP(), multiple deposits: updates user's deposit and snapshots (1058ms)
      ✔ provideToSP(): reverts if user tries to provide more than their ANTUSD balance (302ms)
      ✔ provideToSP(): reverts if user tries to provide 2^256-1 ANTUSD, which exceeds their balance (265ms)
      - provideToSP(): reverts if cannot receive ETH Gain
      ✔ provideToSP(): doesn't impact other users' deposits or ETH gains (1086ms)
      ✔ provideToSP(): doesn't impact system debt, collateral or TCR (1071ms)
      ✔ provideToSP(): doesn't impact any troves, including the caller's trove (851ms)
      ✔ provideToSP(): doesn't protect the depositor's trove from liquidation (575ms)
      ✔ provideToSP(): providing 0 ANTUSD reverts (544ms)
      ✔ provideToSP(), new deposit: when SP > 0, triggers LQTY reward event - increases the sum G (581ms)
      ✔ provideToSP(), new deposit: when SP is empty, doesn't update G (518ms)
      ✔ provideToSP(), new deposit: sets the correct front end tag (638ms)
      ✔ provideToSP(), new deposit: depositor does not receive any LQTY rewards (348ms)
      ✔ provideToSP(), new deposit after past full withdrawal: depositor does not receive any LQTY rewards (1067ms)
      ✔ provideToSP(), new eligible deposit: tagged front end receives LQTY rewards (1009ms)
      ✔ provideToSP(), new eligible deposit: tagged front end's stake increases (532ms)
      ✔ provideToSP(), new eligible deposit: tagged front end's snapshots update (903ms)
      ✔ provideToSP(), new deposit: depositor does not receive ETH gains (472ms)
      ✔ provideToSP(), new deposit after past full withdrawal: depositor does not receive ETH gains (1074ms)
      ✔ provideToSP(), topup: triggers LQTY reward event - increases the sum G (668ms)
      ✔ provideToSP(), topup from different front end: doesn't change the front end tag (800ms)
      ✔ provideToSP(), topup: depositor receives LQTY rewards (524ms)
      ✔ provideToSP(), topup: tagged front end receives LQTY rewards (765ms)
      ✔ provideToSP(), topup: tagged front end's stake increases (1076ms)
      ✔ provideToSP(), topup: tagged front end's snapshots update (1030ms)
      ✔ provideToSP(): reverts when amount is zero (344ms)
      ✔ provideToSP(): reverts if user is a registered front end (411ms)
      ✔ provideToSP(): reverts if provided tag is not a registered front end (253ms)
      ✔ withdrawFromSP(): reverts when user has no active deposit (239ms)
      ✔ withdrawFromSP(): reverts when amount > 0 and system has an undercollateralized trove (226ms)
      ✔ withdrawFromSP(): partial retrieval - retrieves correct ANTUSD amount and the entire ETH Gain, and updates deposit (695ms)
      ✔ withdrawFromSP(): partial retrieval - leaves the correct amount of ANTUSD in the Stability Pool (738ms)
      ✔ withdrawFromSP(): full retrieval - leaves the correct amount of ANTUSD in the Stability Pool (987ms)
      ✔ withdrawFromSP(): Subsequent deposit and withdrawal attempt from same account, with no intermediate liquidations, withdraws zero ETH (925ms)
      ✔ withdrawFromSP(): it correctly updates the user's ANTUSD and ETH snapshots of entitled reward per unit staked (731ms)
      ✔ withdrawFromSP(): decreases StabilityPool ETH (636ms)
      ✔ withdrawFromSP(): All depositors are able to withdraw from the SP to their account (1385ms)
      ✔ withdrawFromSP(): increases depositor's ANTUSD token balance by the expected amount (1220ms)
      ✔ withdrawFromSP(): doesn't impact other users Stability deposits or ETH gains (1007ms)
      ✔ withdrawFromSP(): doesn't impact system debt, collateral or TCR  (1051ms)
      ✔ withdrawFromSP(): doesn't impact any troves, including the caller's trove (575ms)
      ✔ withdrawFromSP(): succeeds when amount is 0 and system has an undercollateralized trove (535ms)
      ✔ withdrawFromSP(): withdrawing 0 ANTUSD doesn't alter the caller's deposit or the total ANTUSD in the Stability Pool (610ms)
      ✔ withdrawFromSP(): withdrawing 0 ETH Gain does not alter the caller's ETH balance, their trove collateral, or the ETH  in the Stability Pool (959ms)
      ✔ withdrawFromSP(): Request to withdraw > caller's deposit only withdraws the caller's compounded deposit (814ms)
      ✔ withdrawFromSP(): Request to withdraw 2^256-1 ANTUSD only withdraws the caller's compounded deposit (1630ms)
      ✔ withdrawFromSP(): caller can withdraw full deposit and ETH gain during Recovery Mode (886ms)
      ✔ getDepositorETHGain(): depositor does not earn further ETH gains from liquidations while their compounded deposit == 0:  (1076ms)
      ✔ withdrawFromSP(): triggers LQTY reward event - increases the sum G (598ms)
      ✔ withdrawFromSP(), partial withdrawal: doesn't change the front end tag (842ms)
      ✔ withdrawFromSP(), partial withdrawal: depositor receives LQTY rewards (554ms)
      ✔ withdrawFromSP(), partial withdrawal: tagged front end receives LQTY rewards (678ms)
      ✔ withdrawFromSP(), partial withdrawal: tagged front end's stake decreases (1022ms)
      ✔ withdrawFromSP(), partial withdrawal: tagged front end's snapshots update (1040ms)
      ✔ withdrawFromSP(), full withdrawal: removes deposit's front end tag (638ms)
      ✔ withdrawFromSP(), full withdrawal: zero's depositor's snapshots (1099ms)
      ✔ withdrawFromSP(), full withdrawal that reduces front end stake to 0: zero’s the front end’s snapshots (935ms)
      ✔ withdrawFromSP(), reverts when initial deposit value is 0 (621ms)
      ✔ withdrawETHGainToTrove(): reverts when user has no active deposit (500ms)
      ✔ withdrawETHGainToTrove(): Applies ANTUSDLoss to user's deposit, and redirects ETH reward to user's Trove (562ms)
      ✔ withdrawETHGainToTrove(): reverts if it would leave trove with ICR < MCR (550ms)
      ✔ withdrawETHGainToTrove(): Subsequent deposit and withdrawal attempt from same account, with no intermediate liquidations, withdraws zero ETH (681ms)
      ✔ withdrawETHGainToTrove(): decreases StabilityPool ETH and increases activePool ETH (574ms)
      ✔ withdrawETHGainToTrove(): All depositors are able to withdraw their ETH gain from the SP to their Trove (1622ms)
      ✔ withdrawETHGainToTrove(): All depositors withdraw, each withdraw their correct ETH gain (2413ms)
      ✔ withdrawETHGainToTrove(): caller can withdraw full deposit and ETH gain to their trove during Recovery Mode (865ms)
      ✔ withdrawETHGainToTrove(): reverts if user has no trove (669ms)
      ✔ withdrawETHGainToTrove(): triggers LQTY reward event - increases the sum G (991ms)
      ✔ withdrawETHGainToTrove(), partial withdrawal: doesn't change the front end tag (1040ms)
      ✔ withdrawETHGainToTrove(), eligible deposit: depositor receives LQTY rewards (1005ms)
      ✔ withdrawETHGainToTrove(), eligible deposit: tagged front end receives LQTY rewards (1012ms)
      ✔ withdrawETHGainToTrove(), eligible deposit: tagged front end's stake decreases (1543ms)
      ✔ withdrawETHGainToTrove(), eligible deposit: tagged front end's snapshots update (1178ms)
      ✔ withdrawETHGainToTrove(): reverts when depositor has no ETH gain (712ms)
      ✔ registerFrontEnd(): registers the front end and chosen kickback rate (161ms)
      ✔ registerFrontEnd(): reverts if the front end is already registered
      ✔ registerFrontEnd(): reverts if the kickback rate >1 (38ms)
      ✔ registerFrontEnd(): reverts if address has a non-zero deposit already (447ms)

  Contract: TroveManager
totalStakesSnapshot after L1: 200000002000000000000000000000
totalCollateralSnapshot after L1: 399000002000000000000000000000
Snapshots ratio after L1: 501253135332064484
B pending ETH reward after L1: 39799999602000003960000000000
B stake after L1: 40000000000000000000000000000
B stake after A1: 39999999999999999989974957243
Snapshots ratio after A1: 501253135332064484
B stake after L2: 39999999999999999989974957243
Snapshots ratio after L2: 501253134833317619
B stake after A2: 39999999999999999983267686056
B stake after L3: 39999999999999999983267686056
Snapshots ratio after L3: 501253134334570755
B stake after A3: 39999999999999999978023472178
B stake after L4: 39999999999999999978023472178
Snapshots ratio after L4: 501253133835823890
B stake after A4: 39999999999999999993921497875
B stake after L5: 39999999999999999993921497875
Snapshots ratio after L5: 501253133337077025
B stake after A5: 39999999999999999994797348633
B stake after L6: 39999999999999999994797348633
Snapshots ratio after L6: 501253132838330161
B stake after A6: 39999999999999999993468266716
B stake after L7: 39999999999999999993468266716
Snapshots ratio after L7: 501253132339583296
B stake after A7: 39999999999999999992497700314
B stake after L8: 39999999999999999992497700314
Snapshots ratio after L8: 501253131840836431
B stake after A8: 39999999999999999992398338824
B stake after L9: 39999999999999999992398338824
Snapshots ratio after L9: 501253131342089567
B stake after A9: 39999999999999999993272719884
B stake after L10: 39999999999999999993272719884
Snapshots ratio after L10: 501253130843342702
B stake after A10: 39999999999999999995141350785
B stake after L11: 39999999999999999995141350785
Snapshots ratio after L11: 501253130344595837
B stake after A11: 39999999999999999998008332745
    ✔ A given trove's stake decline is negligible with adjustments and tiny liquidations (4143ms)

  Contract: TroveManager - Redistribution reward calculations
    ✔ redistribution: A, B Open. B Liquidated. C, D Open. D Liquidated. Distributes correct rewards (556ms)
    ✔ redistribution: A, B, C Open. C Liquidated. D, E, F Open. F Liquidated. Distributes correct rewards (1206ms)
    ✔ redistribution: Sequence of alternate opening/liquidation: final surviving trove has ETH from all previously liquidated troves (1524ms)
    ✔ redistribution: A,B,C,D,E open. Liq(A). B adds coll. Liq(C). B and D have correct coll and debt (1072ms)
    ✔ redistribution: A,B,C,D open. Liq(A). B adds coll. Liq(C). B and D have correct coll and debt (1798ms)
    ✔ redistribution: A,B,C Open. Liq(C). B adds coll. Liq(A). B acquires all coll and debt (616ms)
    ✔ redistribution: A,B,C Open. Liq(C). B tops up coll. D Opens. Liq(D). Distributes correct rewards. (796ms)
    ✔ redistribution: Trove with the majority stake tops up. A,B,C, D open. Liq(D). C tops up. E Enters, Liq(E). Distributes correct rewards (834ms)
    ✔ redistribution: Trove with the majority stake tops up. A,B,C, D open. Liq(D). A, B, C top up. E Enters, Liq(E). Distributes correct rewards (926ms)
    ✔ redistribution: A,B,C Open. Liq(C). B withdraws coll. Liq(A). B acquires all coll and debt (724ms)
    ✔ redistribution: A,B,C Open. Liq(C). B withdraws coll. D Opens. Liq(D). Distributes correct rewards. (640ms)
    ✔ redistribution: Trove with the majority stake withdraws. A,B,C,D open. Liq(D). C withdraws some coll. E Enters, Liq(E). Distributes correct rewards (583ms)
    ✔ redistribution: Trove with the majority stake withdraws. A,B,C,D open. Liq(D). A, B, C withdraw. E Enters, Liq(E). Distributes correct rewards (1029ms)
    ✔ redistribution, all operations: A,B,C open. Liq(A). D opens. B adds, C withdraws. Liq(B). E & F open. D adds. Liq(F). Distributes correct rewards (1170ms)
    ✔ redistribution, all operations: A,B,C open. Liq(A). D opens. B adds, C withdraws. Liq(B). E & F open. D adds. Liq(F). Varying coll. Distributes correct rewards (1232ms)

  Contract: TroveManager - in Recovery Mode - back to normal mode in 1 tx
    Batch liquidations
      ✔ First trove only doesn’t get out of Recovery Mode (641ms)
      ✔ Two troves over MCR are liquidated (593ms)
      ✔ Stability Pool profit matches (453ms)
      ✔ A trove over TCR is not liquidated (648ms)
    Sequential liquidations
      ✔ First trove only doesn’t get out of Recovery Mode (776ms)
      ✔ Two troves over MCR are liquidated (405ms)

  Contract: TroveManager - in Recovery Mode
    ✔ checkRecoveryMode(): Returns true if TCR falls below CCR (187ms)
    ✔ checkRecoveryMode(): Returns true if TCR stays less than CCR (223ms)
    ✔ checkRecoveryMode(): returns false if TCR stays above CCR (213ms)
    ✔ checkRecoveryMode(): returns false if TCR rises above CCR (235ms)
    ✔ liquidate(), with ICR < 100%: removes stake and updates totalStakes (230ms)
    ✔ liquidate(), with ICR < 100%: updates system snapshots correctly (565ms)
    ✔ liquidate(), with ICR < 100%: closes the Trove and removes it from the Trove array (450ms)
    ✔ liquidate(), with ICR < 100%: only redistributes to active Troves - no offset to Stability Pool (631ms)
    ✔ liquidate(), with 100 < ICR < 110%: removes stake and updates totalStakes (385ms)
    ✔ liquidate(), with 100% < ICR < 110%: updates system snapshots correctly (513ms)
    ✔ liquidate(), with 100% < ICR < 110%: closes the Trove and removes it from the Trove array (267ms)
    ✔ liquidate(), with 100% < ICR < 110%: offsets as much debt as possible with the Stability Pool, then redistributes the remainder coll and debt (669ms)
    ✔ liquidate(), with ICR > 110%, trove has lowest ICR, and StabilityPool is empty: does nothing (572ms)
    ✔ liquidate(), with 110% < ICR < TCR, and StabilityPool ANTUSD > debt to liquidate: offsets the trove entirely with the pool (416ms)
    ✔ liquidate(), with ICR% = 110 < TCR, and StabilityPool ANTUSD > debt to liquidate: offsets the trove entirely with the pool, there’s no collateral surplus (447ms)
    ✔ liquidate(), with  110% < ICR < TCR, and StabilityPool ANTUSD > debt to liquidate: removes stake and updates totalStakes (648ms)
    ✔ liquidate(), with  110% < ICR < TCR, and StabilityPool ANTUSD > debt to liquidate: updates system snapshots (453ms)
    ✔ liquidate(), with 110% < ICR < TCR, and StabilityPool ANTUSD > debt to liquidate: closes the Trove (662ms)
    ✔ liquidate(), with 110% < ICR < TCR, and StabilityPool ANTUSD > debt to liquidate: can liquidate troves out of order (1220ms)
    ✔ liquidate(), with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: Trove remains active (386ms)
    ✔ liquidate(), with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: Trove remains in TroveOwners array (522ms)
    ✔ liquidate(), with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: nothing happens (556ms)
    ✔ liquidate(), with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: updates system shapshots (450ms)
    ✔ liquidate(), with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: causes correct Pool offset and ETH gain, and doesn't redistribute to active troves (382ms)
    ✔ liquidate(), with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: ICR of non liquidated trove does not change (1199ms)
    ✔ liquidate() with ICR > 110%, and StabilityPool ANTUSD < liquidated debt: total liquidated coll and debt is correct (662ms)
    ✔ liquidate(): Doesn't liquidate undercollateralized trove if it is the only trove in the system (403ms)
    ✔ liquidate(): Liquidates undercollateralized trove if there are two troves in the system (511ms)
    ✔ liquidate(): does nothing if trove has >= 110% ICR and the Stability Pool is empty (1262ms)
    ✔ liquidate(): does nothing if trove ICR >= TCR, and SP covers trove's debt (370ms)
    ✔ liquidate(): reverts if trove is non-existent (167ms)
    ✔ liquidate(): reverts if trove has been closed (322ms)
    ✔ liquidate(): liquidates based on entire/collateral debt (including pending rewards), not raw collateral/debt (981ms)
    ✔ liquidate(): does not affect the SP deposit or ETH gain when called on an SP depositor's address that has no trove (302ms)
    ✔ liquidate(): does not alter the liquidated user's token balance (824ms)
    ✔ liquidate(), with 110% < ICR < TCR, can claim collateral, re-open, be reedemed and claim again (1029ms)
    ✔ liquidate(), with 110% < ICR < TCR, can claim collateral, after another claim from a redemption (995ms)
    ✔ liquidateTroves(): With all ICRs > 110%, Liquidates Troves until system leaves recovery mode (1300ms)
    ✔ liquidateTroves(): Liquidates Troves until 1) system has left recovery mode AND 2) it reaches a Trove with ICR >= 110% (939ms)
    ✔ liquidateTroves(): liquidates only up to the requested number of undercollateralized troves (1058ms)
    ✔ liquidateTroves(): does nothing if n = 0 (616ms)
    ✔ liquidateTroves(): closes every Trove with ICR < MCR, when n > number of undercollateralized troves (1039ms)
    ✔ liquidateTroves(): a liquidation sequence containing Pool offsets increases the TCR (1185ms)
    ✔ liquidateTroves(): A liquidation sequence of pure redistributions decreases the TCR, due to gas compensation, but up to 0.5% (1130ms)
    ✔ liquidateTroves(): liquidates based on entire/collateral debt (including pending rewards), not raw collateral/debt (704ms)
    ✔ liquidateTroves(): does nothing if all troves have ICR > 110% and Stability Pool is empty (456ms)
    ✔ liquidateTroves(): emits liquidation event with correct values when all troves have ICR > 110% and Stability Pool covers a subset of troves (997ms)
    ✔ liquidateTroves():  emits liquidation event with correct values when all troves have ICR > 110% and Stability Pool covers a subset of troves, including a partial (1002ms)
    ✔ liquidateTroves(): does not affect the liquidated user's token balances (519ms)
    ✔ liquidateTroves(): Liquidating troves at 100 < ICR < 110 with SP deposits correctly impacts their SP deposit and ETH gain (731ms)
    ✔ liquidateTroves(): Liquidating troves at ICR <=100% with SP deposits does not alter their deposit or ETH gain (751ms)
    ✔ liquidateTroves() with a non fullfilled liquidation: non liquidated trove remains active (767ms)
    ✔ liquidateTroves() with a non fullfilled liquidation: non liquidated trove remains in TroveOwners Array (1032ms)
gasUsed:  753684
true
    ✔ liquidateTroves() with a non fullfilled liquidation: still can liquidate further troves after the non-liquidated, emptied pool (850ms)
gasUsed:  753684
    ✔ liquidateTroves() with a non fullfilled liquidation: still can liquidate further troves after the non-liquidated, non emptied pool (1333ms)
    ✔ liquidateTroves() with a non fullfilled liquidation: total liquidated coll and debt is correct (816ms)
    ✔ liquidateTroves() with a non fullfilled liquidation: emits correct liquidation event values (908ms)
    ✔ liquidateTroves() with a non fullfilled liquidation: ICR of non liquidated trove does not change (930ms)
    ✔ batchLiquidateTroves(): Liquidates all troves with ICR < 110%, transitioning Normal -> Recovery Mode (995ms)
    ✔ batchLiquidateTroves(): Liquidates all troves with ICR < 110%, transitioning Recovery -> Normal Mode (975ms)
    ✔ batchLiquidateTroves(): Liquidates all troves with ICR < 110%, transitioning Normal -> Recovery Mode (1104ms)
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: non liquidated trove remains active (880ms)
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: non liquidated trove remains in Trove Owners array (790ms)
gasUsed:  765825
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: still can liquidate further troves after the non-liquidated, emptied pool (1003ms)
gasUsed:  765825
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: still can liquidate further troves after the non-liquidated, non emptied pool (958ms)
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: total liquidated coll and debt is correct (707ms)
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: emits correct liquidation event values (879ms)
    ✔ batchLiquidateTroves() with a non fullfilled liquidation: ICR of non liquidated trove does not change (691ms)
    ✔ batchLiquidateTroves(), with 110% < ICR < TCR, and StabilityPool ANTUSD > debt to liquidate: can liquidate troves out of order (1246ms)
    ✔ batchLiquidateTroves(), with 110% < ICR < TCR, and StabilityPool empty: doesn't liquidate any troves (868ms)
    ✔ batchLiquidateTroves(): skips liquidation of troves with ICR > TCR, regardless of Stability Pool size (1752ms)
    ✔ batchLiquidateTroves(): emits liquidation event with correct values when all troves have ICR > 110% and Stability Pool covers a subset of troves (1115ms)
    ✔ batchLiquidateTroves(): emits liquidation event with correct values when all troves have ICR > 110% and Stability Pool covers a subset of troves, including a partial (1007ms)

  Contract: TroveManager
    ✔ liquidate(): closes a Trove that has ICR < MCR (356ms)
    ✔ liquidate(): decreases ActivePool ETH and ANTUSDDebt by correct amounts (214ms)
    ✔ liquidate(): increases DefaultPool ETH and ANTUSD debt by correct amounts (245ms)
    ✔ liquidate(): removes the Trove's stake from the total stakes (641ms)
    ✔ liquidate(): Removes the correct trove from the TroveOwners array, and moves the last array element to the new empty slot (719ms)
    ✔ liquidate(): updates the snapshots of total stakes and total collateral (358ms)
    ✔ liquidate(): updates the L_ETH and L_ANTUSDDebt reward-per-unit-staked totals (718ms)
    ✔ liquidate(): Liquidates undercollateralized trove if there are two troves in the system (373ms)
    ✔ liquidate(): reverts if trove is non-existent (441ms)
    ✔ liquidate(): reverts if trove has been closed (707ms)
    ✔ liquidate(): does nothing if trove has >= 110% ICR (253ms)
    ✔ liquidate(): Given the same price and no other trove changes, complete Pool offsets restore the TCR to its value prior to the defaulters opening troves (1682ms)
    ✔ liquidate(): Pool offsets increase the TCR (1603ms)
    ✔ liquidate(): a pure redistribution reduces the TCR only as a result of compensation (1672ms)
    ✔ liquidate(): does not affect the SP deposit or ETH gain when called on an SP depositor's address that has no trove (367ms)
    ✔ liquidate(): does not liquidate a SP depositor's trove with ICR > 110%, and does not affect their SP deposit or ETH gain (393ms)
    ✔ liquidate(): liquidates a SP depositor's trove with ICR < 110%, and the liquidation correctly impacts their SP deposit and ETH gain (905ms)
    ✔ liquidate(): does not alter the liquidated user's token balance (756ms)
    ✔ liquidate(): liquidates based on entire/collateral debt (including pending rewards), not raw collateral/debt (924ms)
    ✔ liquidate(): when SP > 0, triggers LQTY reward event - increases the sum G (768ms)
    ✔ liquidate(): when SP is empty, doesn't update G (689ms)
    ✔ liquidateTroves(): liquidates a Trove that a) was skipped in a previous liquidation and b) has pending rewards (1177ms)
    ✔ liquidateTroves(): closes every Trove with ICR < MCR, when n > number of undercollateralized troves (1497ms)
    ✔ liquidateTroves(): liquidates  up to the requested number of undercollateralized troves (625ms)
    ✔ liquidateTroves(): does nothing if all troves have ICR > 110% (655ms)
    ✔ liquidateTroves(): liquidates based on entire/collateral debt (including pending rewards), not raw collateral/debt (807ms)
    ✔ liquidateTroves(): reverts if n = 0 (502ms)
    ✔ liquidateTroves():  liquidates troves with ICR < MCR (1024ms)
    ✔ liquidateTroves(): does not affect the liquidated user's token balances (765ms)
    ✔ liquidateTroves(): A liquidation sequence containing Pool offsets increases the TCR (1575ms)
    ✔ liquidateTroves(): A liquidation sequence of pure redistributions decreases the TCR, due to gas compensation, but up to 0.5% (1310ms)
    ✔ liquidateTroves(): Liquidating troves with SP deposits correctly impacts their SP deposit and ETH gain (645ms)
    ✔ liquidateTroves(): when SP > 0, triggers LQTY reward event - increases the sum G (910ms)
    ✔ liquidateTroves(): when SP is empty, doesn't update G (958ms)
    ✔ batchLiquidateTroves(): liquidates a Trove that a) was skipped in a previous liquidation and b) has pending rewards (1150ms)
    ✔ batchLiquidateTroves(): closes every trove with ICR < MCR in the given array (902ms)
    ✔ batchLiquidateTroves(): does not liquidate troves that are not in the given array (711ms)
    ✔ batchLiquidateTroves(): does not close troves with ICR >= MCR in the given array (966ms)
    ✔ batchLiquidateTroves(): reverts if array is empty (462ms)
    ✔ batchLiquidateTroves(): skips if trove is non-existent (946ms)
    ✔ batchLiquidateTroves(): skips if a trove has been closed (1012ms)
    ✔ batchLiquidateTroves: when SP > 0, triggers LQTY reward event - increases the sum G (803ms)
    ✔ batchLiquidateTroves(): when SP is empty, doesn't update G (925ms)
    ✔ getRedemptionHints(): gets the address of the first Trove and the final ICR of the last Trove involved in a redemption (428ms)
    ✔ getRedemptionHints(): returns 0 as partialRedemptionHintNICR when reaching _maxIterations (516ms)
    ✔ redeemCollateral(): cancels the provided ANTUSD with debt from Troves with the lowest ICRs and sends an equivalent amount of Ether (476ms)
    ✔ redeemCollateral(): with invalid first hint, zero address (811ms)
    ✔ redeemCollateral(): with invalid first hint, non-existent trove (694ms)
    ✔ redeemCollateral(): with invalid first hint, trove below MCR (904ms)
    ✔ redeemCollateral(): ends the redemption sequence when the token redemption request has been filled (964ms)
    ✔ redeemCollateral(): ends the redemption sequence when max iterations have been reached (589ms)
    ✔ redeemCollateral(): performs partial redemption if resultant debt is > minimum net debt (895ms)
    ✔ redeemCollateral(): doesn't perform partial redemption if resultant debt would be < minimum net debt (725ms)
    ✔ redeemCollateral(): doesnt perform the final partial redemption in the sequence if the hint is out-of-date (677ms)
    - redeemCollateral(): can redeem if there is zero active debt but non-zero debt in DefaultPool
    ✔ redeemCollateral(): doesn't touch Troves with ICR < 110% (362ms)
    ✔ redeemCollateral(): finds the last Trove with ICR == 110% even if there is more than one (808ms)
    ✔ redeemCollateral(): reverts when TCR < MCR (789ms)
    ✔ redeemCollateral(): reverts when argument _amount is 0 (542ms)
    ✔ redeemCollateral(): reverts if max fee > 100% (1376ms)
    ✔ redeemCollateral(): reverts if max fee < 0.5% (1478ms)
    ✔ redeemCollateral(): reverts if fee exceeds max fee percentage (1549ms)
    ✔ redeemCollateral(): succeeds if fee is less than max fee percentage (2049ms)
    ✔ redeemCollateral(): doesn't affect the Stability Pool deposits or ETH gain of redeemed-from troves (1654ms)
    ✔ redeemCollateral(): caller can redeem their entire ANTUSDToken balance (867ms)
    ✔ redeemCollateral(): reverts when requested redemption amount exceeds caller's ANTUSD token balance (1145ms)
    ✔ redeemCollateral(): value of issued ETH == face value of redeemed ANTUSD (assuming 1 ANTUSD has value of $1) (1004ms)
    ✔ redeemCollateral(): reverts if there is zero outstanding system debt (39ms)
    ✔ redeemCollateral(): reverts if caller's tries to redeem more than the outstanding system debt (256ms)
    ✔ redeemCollateral(): a redemption made when base rate is zero increases the base rate (805ms)
    ✔ redeemCollateral(): a redemption made when base rate is non-zero increases the base rate, for negligible time passed (1194ms)
    ✔ redeemCollateral(): lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation [ @skip-on-coverage ] (2778ms)
    ✔ redeemCollateral(): a redemption made at zero base rate send a non-zero ETHFee to LQTY staking contract (941ms)
    ✔ redeemCollateral(): a redemption made at zero base increases the ETH-fees-per-LQTY-staked in LQTY Staking contract (744ms)
    ✔ redeemCollateral(): a redemption made at a non-zero base rate send a non-zero ETHFee to LQTY staking contract (1322ms)
    ✔ redeemCollateral(): a redemption made at a non-zero base rate increases ETH-per-LQTY-staked in the staking contract (1582ms)
    ✔ redeemCollateral(): a redemption sends the ETH remainder (ETHDrawn - ETHFee) to the redeemer (875ms)
    ✔ redeemCollateral(): a full redemption (leaving trove with 0 debt), closes the trove (1051ms)
    ✔ redeemCollateral(): emits correct debt and coll values in each redeemed trove's TroveUpdated event (1037ms)
    ✔ redeemCollateral(): a redemption that closes a trove leaves the trove's ETH surplus (collateral - ETH drawn) available for the trove owner to claim (1169ms)
    ✔ redeemCollateral(): a redemption that closes a trove leaves the trove's ETH surplus (collateral - ETH drawn) available for the trove owner after re-opening trove (1629ms)
    ✔ redeemCollateral(): reverts if fee eats up all returned collateral (1445ms)
    ✔ getPendingANTUSDDebtReward(): Returns 0 if there is no pending ANTUSDDebt reward (325ms)
    ✔ getPendingETHReward(): Returns 0 if there is no pending ETH reward (356ms)
    ✔ computeICR(): Returns 0 if trove's coll is worth 0
    ✔ computeICR(): Returns 2^256-1 for ETH:USD = 100, coll = 1 ETH, debt = 100 ANTUSD
    ✔ computeICR(): returns correct ICR for ETH:USD = 100, coll = 200 ETH, debt = 30 ANTUSD
    ✔ computeICR(): returns correct ICR for ETH:USD = 250, coll = 1350 ETH, debt = 127 ANTUSD
    ✔ computeICR(): returns correct ICR for ETH:USD = 100, coll = 1 ETH, debt = 54321 ANTUSD
    ✔ computeICR(): Returns 2^256-1 if trove has non-zero coll and zero debt
    ✔ checkRecoveryMode(): Returns true when TCR < 150% (566ms)
    ✔ checkRecoveryMode(): Returns false when TCR == 150% (192ms)
    ✔ checkRecoveryMode(): Returns false when TCR > 150% (175ms)
    ✔ checkRecoveryMode(): Returns false when TCR == 0 (342ms)
    ✔ getTroveStake(): Returns stake (172ms)
    ✔ getTroveColl(): Returns coll (151ms)
    ✔ getTroveDebt(): Returns debt (181ms)
    ✔ getTroveStatus(): Returns status (227ms)
    ✔ hasPendingRewards(): Returns false it trove is not active

  Contract: Unipool
    Unipool
      ✔ Two stakers with the same stakes wait DURATION (245ms)
      ✔ Two stakers with the different (1:3) stakes wait DURATION (53ms)
      ✔ Two stakers with the different (1:3) stakes wait DURATION and DURATION/2 (200ms)
      ✔ Three stakers with the different (1:3:5) stakes wait different durations (323ms)
      ✔ Four stakers with gaps of zero total supply (897ms)
      ✔ Four stakers with gaps of zero total supply, with claims in between (506ms)
    Unipool, before calling setAddresses
      ✔ Stake fails (48ms)
      ✔ Withdraw falis
      ✔ Claim fails
      ✔ Exit fails (58ms)


  975 passing (2h)
  14 pending
  14 failing

  1) Contract: Access Control: Liquity functions with the caller restricted to Liquity contract(s)
       "before all" hook in "Contract: Access Control: Liquity functions with the caller restricted to Liquity contract(s)":
     TypeError: deploymentHelper.deployLUSDTokenTester is not a function
      at Context.<anonymous> (test/AccessControlTest.js:45:44)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  2) Contract: Deployment script - Sets correct contract addresses dependencies after deployment
       Sets the correct ANTUSDToken address in TroveManager:
     TypeError: troveManager.lusdToken is not a function
      at Context.<anonymous> (test/ConnectContractsTest.js:57:56)
      at processImmediate (node:internal/timers:478:21)

  3) Contract: Deployment script - Sets correct contract addresses dependencies after deployment
       Sets the correct ANTUSDToken address in StabilityPool:
     TypeError: stabilityPool.lusdToken is not a function
      at Context.<anonymous> (test/ConnectContractsTest.js:166:57)
      at processImmediate (node:internal/timers:478:21)

  4) Contract: Deployment script - Sets correct contract addresses dependencies after deployment
       Sets the correct ActivePool address in LQTYStaking:
     TypeError: lqtyStaking.lusdToken is not a function
      at Context.<anonymous> (test/ConnectContractsTest.js:281:58)
      at processImmediate (node:internal/timers:478:21)

  5) Contract: LQTY Token
       permit(): permits and emits an Approval event (replay protected):
     Error: VM Exception while processing transaction: reverted with reason string 'LQTY: invalid signature'
    at LQTYTokenTester.permit (contracts/LQTY/LQTYToken.sol:258)
    at TruffleContract.permit (/Users/maytham/j/persistant.money/node_modules/@nomiclabs/truffle-contract/lib/execute.js:169:26)
    at buildPermitTx (test/GrowthTokenTest.js:102:32)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at Context.<anonymous> (test/GrowthTokenTest.js:345:29)
  

  6) Contract: ANTUSDToken
       Basic token functions, without Proxy
         name(): returns the token's name:

      AssertionError: expected 'LUSD Stablecoin' to equal 'ANTUSD Stablecoin'
      + expected - actual

      -LUSD Stablecoin
      +ANTUSD Stablecoin
      
      at Context.<anonymous> (test/LUSDTokenTest.js:125:14)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  7) Contract: ANTUSDToken
       Basic token functions, without Proxy
         symbol(): returns the token's symbol:

      AssertionError: expected 'LUSD' to equal 'ANTUSD'
      + expected - actual

      -LUSD
      +ANTUSD
      
      at Context.<anonymous> (test/LUSDTokenTest.js:130:14)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  8) Contract: ANTUSDToken
       Basic token functions, without Proxy
         permits and emits an Approval event (replay protected):
     Error: VM Exception while processing transaction: reverted with reason string 'LUSD: invalid signature'
    at ANTUSDTokenTester.permit (contracts/ANTUSDToken.sol:190)
    at TruffleContract.permit (/Users/maytham/j/persistant.money/node_modules/@nomiclabs/truffle-contract/lib/execute.js:169:26)
    at buildPermitTx (test/LUSDTokenTest.js:350:36)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at Context.<anonymous> (test/LUSDTokenTest.js:362:33)
  

  9) Contract: ANTUSDToken
       Basic token functions, with Proxy
         name(): returns the token's name:

      AssertionError: expected 'LUSD Stablecoin' to equal 'ANTUSD Stablecoin'
      + expected - actual

      -LUSD Stablecoin
      +ANTUSD Stablecoin
      
      at Context.<anonymous> (test/LUSDTokenTest.js:125:14)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  10) Contract: ANTUSDToken
       Basic token functions, with Proxy
         symbol(): returns the token's symbol:

      AssertionError: expected 'LUSD' to equal 'ANTUSD'
      + expected - actual

      -LUSD
      +ANTUSD
      
      at Context.<anonymous> (test/LUSDTokenTest.js:130:14)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  11) Contract: StabilityPool Scale Factor issue tests
       Scale Factor issue tests
         1. Liquidation succeeds after P reduced to 1:
     Error: VM Exception while processing transaction: invalid opcode
    at StabilityPool._updateRewardSumAndProduct (contracts/StabilityPool.sol:628)
    at TroveManagerTester.batchLiquidateTroves (contracts/TroveManager.sol:667)
    at TroveManagerTester.liquidate (contracts/TroveManager.sol:308)
    at TruffleContract.liquidate (/Users/maytham/j/persistant.money/node_modules/@nomiclabs/truffle-contract/lib/execute.js:169:26)
    at Context.<anonymous> (test/SP_P_TruncationTest.js:130:24)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
  

  12) Contract: StabilityPool - LQTY Rewards
       LQTY Rewards
         withdrawFromSP(): Depositors with equal initial deposit withdraw correct LQTY gain. No liquidations. No front end.:

      AssertionError: expected 60184946562140560000 to be at most 1000000000000
      + expected - actual

      -60184946562140560000
      +1000000000000
      
      at Context.<anonymous> (test/StabilityPool_LQTYIssuanceTest.js:272:14)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  13) Contract: StabilityPool - LQTY Rewards
       LQTY Rewards
         withdrawFromSP(): Depositor withdraws correct LQTY gain after serial pool-emptying liquidations. No front-ends.:

      AssertionError: expected 622538091449008000000 to be at most 1000000000000000
      + expected - actual

      -622538091449008000000
      +1000000000000000
      
      at Context.<anonymous> (test/StabilityPool_LQTYIssuanceTest.js:609:16)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)

  14) Contract: StabilityPool - LQTY Rewards
       LQTY Rewards
         withdrawFromSP(): Depositors with equal initial deposit withdraw correct LQTY gain. No liquidations. Front ends and kickback rates.:

      AssertionError: expected 31650180466978664000 to be at most 1000000000000
      + expected - actual

      -31650180466978664000
      +1000000000000
      
      at Context.<anonymous> (test/StabilityPool_LQTYIssuanceTest.js:961:14)
      at processTicksAndRejections (node:internal/process/task_queues:95:5)



