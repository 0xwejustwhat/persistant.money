

  EthersLiquity
    ✔ should get the price
    findHintForCollateralRatio
      ✔ should pick the closest approx hint
    Trove
      ✔ should have no Trove initially
      ✔ should fail to create an undercollateralized Trove
      ✔ should fail to create a Trove with too little debt
      1) should create a Trove with some borrowing
      ✔ should fail to withdraw all the collateral while the Trove has debt
      2) should repay some debt
      3) should borrow some more
      4) should deposit more collateral
      5) should repay some debt and withdraw some collateral at the same time
      6) should borrow more and deposit some collateral at the same time
      7) should close the Trove with some LUSD from another user
    SendableEthersLiquity
      ✔ should parse failed transactions without throwing
    Frontend
      ✔ should have no frontend initially
      ✔ should register a frontend
      ✔ should have a frontend now
      8) other user's deposit should be tagged with the frontend's address
    StabilityPool
      9) should make a small stability deposit
      10) other user should make a Trove with very low ICR
      ✔ the price should take a dip
      11) should liquidate other user's Trove
      12) should have a depleted stability deposit and some collateral gain
      13) the Trove should have received some liquidation shares
      14) total should equal the Trove
      15) should transfer the gains to the Trove
      when people overstay
        16) "before all" hook for "should still be able to withdraw remaining deposit"
    Redemption
      17) should fail to redeem during the bootstrap phase
      18) should redeem some LUSD after the bootstrap phase
      19) should claim the collateral surplus after redemption
      20) borrowing rate should be maxed out now
    Redemption (truncation)
      21) "before each" hook for "should truncate the amount if it would put the last Trove below the min debt"
    Redemption (gas checks)
      22) "before all" hook for "should redeem using the maximum iterations and almost all gas"
    Liquidity mining
      ✔ should obtain some UNI LP tokens
      ✔ should fail to stake UNI LP before approving the spend
      ✔ should stake UNI LP after approving the spend (101ms)
      ✔ should have an LQTY reward after some time has passed (4162ms)
      ✔ should partially unstake
      ✔ should unstake remaining tokens and withdraw remaining LQTY reward (1225ms)
      ✔ should have no more rewards after the mining period is over (231ms)
    Hints (adjustTrove)
      23) "before all" hook for "should not use extra gas when a Trove's position doesn't change"
    Gas estimation
      24) "before all" hook for "should include enough gas for updating lastFeeOperationTime"
    Gas estimation (LQTY issuance)
      25) should include enough gas for issuing LQTY
    Gas estimation (fee decay)
      26) "before all" hook for "should predict the gas increase due to fee decay"


  18 passing (19s)
  26 failing

  1) EthersLiquity
       Trove
         should create a Trove with some borrowing:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0xFC623e91a3A638718cDA6dCC108BD60a9F8109E1","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000066ffcbfd5e5a30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b1880000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  2) EthersLiquity
       Trove
         should repay some debt:

      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment")

      + expected - actual

      -false
      +true
      
      at UserTrove.adjustTo (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:710:11)
      at PopulatableEthersLiquity.adjustTrove (src/PopulatableEthersLiquity.ts:1000:63)
      at async Context.<anonymous> (test/Liquity.test.ts:302:33)

  3) EthersLiquity
       Trove
         should borrow some more:

      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment")

      + expected - actual

      -false
      +true
      
      at UserTrove.adjustTo (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:710:11)
      at PopulatableEthersLiquity.adjustTrove (src/PopulatableEthersLiquity.ts:1000:63)
      at async Context.<anonymous> (test/Liquity.test.ts:310:33)

  4) EthersLiquity
       Trove
         should deposit more collateral:

      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment")

      + expected - actual

      -false
      +true
      
      at UserTrove.adjustTo (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:710:11)
      at PopulatableEthersLiquity.adjustTrove (src/PopulatableEthersLiquity.ts:1000:63)
      at async Context.<anonymous> (test/Liquity.test.ts:320:28)

  5) EthersLiquity
       Trove
         should repay some debt and withdraw some collateral at the same time:

      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment")

      + expected - actual

      -false
      +true
      
      at UserTrove.adjustTo (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:710:11)
      at PopulatableEthersLiquity.adjustTrove (src/PopulatableEthersLiquity.ts:1000:63)
      at async waitForSuccess (test/Liquity.test.ts:83:26)
      at async Context.<anonymous> (test/Liquity.test.ts:335:11)

  6) EthersLiquity
       Trove
         should borrow more and deposit some collateral at the same time:

      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment")

      + expected - actual

      -false
      +true
      
      at UserTrove.adjustTo (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:710:11)
      at PopulatableEthersLiquity.adjustTrove (src/PopulatableEthersLiquity.ts:1000:63)
      at async waitForSuccess (test/Liquity.test.ts:83:26)
      at async Context.<anonymous> (test/Liquity.test.ts:359:11)

  7) EthersLiquity
       Trove
         should close the Trove with some LUSD from another user:
     Error: netDebt should not be used when debt < 200
      at UserTrove.get netDebt [as netDebt] (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:434:13)
      at Context.<anonymous> (test/Liquity.test.ts:384:41)

  8) EthersLiquity
       Frontend
         other user's deposit should be tagged with the frontend's address:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0xcB3E7F6BA9a335069935AC1Af5a5f28aC6B56d3B","to":"0xFC623e91a3A638718cDA6dCC108BD60a9F8109E1","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006c6b935b8bbd40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001158e460913d00000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  9) EthersLiquity
       StabilityPool
         should make a small stability deposit:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0xefaC809C80e25039799EB11b70E157752DC9869e","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006194049f30f720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001158e460913d00000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  10) EthersLiquity
       StabilityPool
         other user should make a Trove with very low ICR:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0xcB3E7F6BA9a335069935AC1Af5a5f28aC6B56d3B","to":"0xefaC809C80e25039799EB11b70E157752DC9869e","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006194049f30f7200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a3298afb5ac71c7","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  11) EthersLiquity
       StabilityPool
         should liquidate other user's Trove:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (error={"name":"TransactionExecutionError","code":-32003,"_isProviderError":true,"data":"0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002254726f76654d616e616765723a206e6f7468696e6720746f206c6971756964617465000000000000000000000000000000000000000000000000000000000000"}, method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0x88400A8e74619127C301B3d8aC7BBd8A08b76f9f","data":"0x653d46e70000000000000000000000000000000000000000000000000000000000000001","accessList":null}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:125:16)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  12) EthersLiquity
       StabilityPool
         should have a depleted stability deposit and some collateral gain:

      AssertionError: expected { Object (initialLUSD, currentLUSD, ...) } to deeply equal { Object (initialLUSD, currentLUSD, ...) }
      + expected - actual

       {
         "collateralGain": {
           "_bigNumber": {
      -      "_hex": "0x00"
      +      "_hex": "0xc3819f6a158426"
             "_isBigNumber": true
           }
         }
         "currentLUSD": {
--
         }
         "frontendTag": "0x0000000000000000000000000000000000000000"
         "initialLUSD": {
           "_bigNumber": {
      -      "_hex": "0x00"
      +      "_hex": "0x8ac7230489e80000"
             "_isBigNumber": true
           }
         }
         "lqtyReward": {
      
      at Context.<anonymous> (test/Liquity.test.ts:542:40)

  13) EthersLiquity
       StabilityPool
         the Trove should have received some liquidation shares:

      AssertionError: expected { Object (collateral, debt, ...) } to deeply equal { Object (ownerAddress, status, ...) }
      + expected - actual

       {
         "collateral": {
           "_bigNumber": {
      -      "_hex": "0x00"
      +      "_hex": "0x01ae37fd9d9d36b4b8"
             "_isBigNumber": true
           }
         }
         "debt": {
           "_bigNumber": {
      -      "_hex": "0x00"
      +      "_hex": "0xd9462c6cb4b5a00000"
             "_isBigNumber": true
           }
         }
         "ownerAddress": "0x2E7108e381e9ACab03aA1B4819aaCB50D2964532"
      -  "status": "nonExistent"
      +  "status": "open"
       }
      
      at Context.<anonymous> (test/Liquity.test.ts:559:29)

  14) EthersLiquity
       StabilityPool
         total should equal the Trove:

      AssertionError: expected 0 to equal 1
      + expected - actual

      -0
      +1
      
      at Context.<anonymous> (test/Liquity.test.ts:578:33)

  15) EthersLiquity
       StabilityPool
         should transfer the gains to the Trove:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'StabilityPool: User must have a non-zero deposit'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0x95468400EDe3ffDd89EaC5e469fdB64966987469","data":"0xfda0101a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":4,"sourceReference":{"sourceName":"contracts/StabilityPool.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/ILUSDToken.sol';\nimport './Interfaces/ISortedTroves.sol';\nimport \"./Interfaces/ICommunityIssuance.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/LiquitySafeMath128.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/IERC20.sol\";\n\n/*\n * The Stability Pool holds LUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its LUSD debt gets offset with\n * LUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of LUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a LUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an ETH gain, as the ETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total LUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and ETH gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and ETH gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated ETH gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated ETH gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated ETH gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding ETH gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated ETH gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the \n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the \n * order of 1e-9. \n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion LUSD has depleted to < 1 LUSD).\n *\n *\n *  --- TRACKING DEPOSITOR'S ETH GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated ETH gain, during the epoch in which the deposit was non-zero and earned ETH.\n *\n * We calculate the depositor's accumulated ETH gain for the scale at which they made the deposit, using the ETH gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated ETH gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An LQTY issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track LQTY gains for depositors, where 'G' is the sum corresponding to LQTY gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n\n    string constant public NAME = \"StabilityPool\";\n\n    address stETHAddress;\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    ILUSDToken public lusdToken;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    ICommunityIssuance public communityIssuance;\n\n    uint256 internal ETH;  // deposited ether tracker\n\n    // Tracker for LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalLUSDDeposits;\n\n   // --- Data structures ---\n\n    struct FrontEnd {\n        uint kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        uint S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping (address => Deposit) public deposits;  // depositor address -> Deposit struct\n    mapping (address => Snapshots) public depositSnapshots;  // depositor address -> snapshots struct\n\n    mapping (address => FrontEnd) public frontEnds;  // front end address -> FrontEnd struct\n    mapping (address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n    mapping (address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some LUSD debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint public P = DECIMAL_PRECISION;\n\n    uint public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* ETH Gain sum 'S': During its lifetime, each deposit d_t earns an ETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    *\n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs.\n    */\n    mapping (uint128 => mapping(uint128 => uint)) public epochToScaleToSum;\n\n    /*\n    * Similarly, the sum 'G' is used to calculate LQTY gains. During it's lifetime, each deposit d_t earns a LQTY gain of\n    *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n    *\n    *  LQTY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n    *  In each case, the LQTY reward is issued (i.e. G is updated), before other state changes are made.\n    */\n    mapping (uint128 => mapping(uint128 => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the LQTY issuance calculation\n    uint public lastLQTYError;\n    // Error trackers for the error correction in the offset calculation\n    uint public lastETHError_Offset;\n    uint public lastLUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\n\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress, \n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_stETHAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        stETHAddress = _stETHAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getTotalLUSDDeposits() external view override returns (uint) {\n        return totalLUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n    * - Tags the deposit with the provided front end tag param, if it's a new deposit\n    * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n    */\n    function provideToSP(uint _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerLQTYIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {_setFrontEndTag(msg.sender, _frontEndTag);}\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedLUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss); // LUSD Loss required for event log\n\n        _sendETHGainToDepositor(depositorETHGain);\n     }\n\n    /*  withdrawFromSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n    * - Removes the deposit's front end tag if it is a full withdrawal\n    * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n    *\n    * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n    */\n    function withdrawFromSP(uint _amount) external override {\n        if (_amount !=0) {_requireNoUnderCollateralizedTroves();}\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerLQTYIssuance(communityIssuanceCached);\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDtoWithdraw = LiquityMath._min(_amount, compoundedLUSDDeposit);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(communityIssuanceCached, msg.sender, frontEnd);\n        \n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.sub(LUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDToDepositor(msg.sender, LUSDtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedLUSDDeposit.sub(LUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);  // LUSD Loss required for event log\n\n        _sendETHGainToDepositor(depositorETHGain);\n    }\n\n    /* withdrawETHGainToTrove:\n    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n    * - Sends all depositor's LQTY gain to  depositor\n    * - Sends all tagged front end's LQTY gain to the tagged front end\n    * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n    * - Leaves their compounded deposit in the Stability Pool\n    * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external override {\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasETHGain(msg.sender);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerLQTYIssuance(communityIssuanceCached);\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _updateDepositAndSnapshots(msg.sender, compoundedLUSDDeposit);\n\n        /* Emit events before transferring ETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the ETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);\n        emit UserDepositChanged(msg.sender, compoundedLUSDDeposit);\n\n        ETH = ETH.sub(depositorETHGain);\n        emit StabilityPoolETHBalanceUpdated(ETH);\n        emit EtherSent(msg.sender, depositorETHGain);\n\n        IERC20(stETHAddress).transfer(address(borrowerOperations), depositorETHGain);\n        borrowerOperations.moveETHGainToTrove(msg.sender, _upperHint, _lowerHint, depositorETHGain);\n    }\n\n    // --- LQTY issuance functions ---\n\n    function _triggerLQTYIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint LQTYIssuance = _communityIssuance.issueLQTY();\n       _updateG(LQTYIssuance);\n    }\n\n    function _updateG(uint _LQTYIssuance) internal {\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        /*\n        * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later\n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n        *\n        */\n        if (totalLUSD == 0 || _LQTYIssuance == 0) {return;}\n\n        uint LQTYPerUnitStaked;\n        LQTYPerUnitStaked =_computeLQTYPerUnitStaked(_LQTYIssuance, totalLUSD);\n\n        uint marginalLQTYGain = LQTYPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalLQTYGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeLQTYPerUnitStaked(uint _LQTYIssuance, uint _totalLUSDDeposits) internal returns (uint) {\n        /*  \n        * Calculate the LQTY-per-unit staked.  Division uses a \"feedback\" error correction, to keep the \n        * cumulative error low in the running total G:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);\n\n        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return LQTYPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint _debtToOffset, uint _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        if (totalLUSD == 0 || _debtToOffset == 0) { return; }\n\n        _triggerLQTYIssuance(communityIssuance);\n\n        (uint ETHGainPerUnitStaked,\n            uint LUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalLUSD);\n\n        _updateRewardSumAndProduct(ETHGainPerUnitStaked, LUSDLossPerUnitStaked);  // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalLUSDDeposits\n    )\n        internal\n        returns (uint ETHGainPerUnitStaked, uint LUSDLossPerUnitStaked)\n    {\n        /*\n        * Compute the LUSD and ETH rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint ETHNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(lastETHError_Offset);\n\n        assert(_debtToOffset <= _totalLUSDDeposits);\n        if (_debtToOffset == _totalLUSDDeposits) {\n            LUSDLossPerUnitStaked = DECIMAL_PRECISION;  // When the Pool depletes to 0, so does each deposit \n            lastLUSDLossError_Offset = 0;\n        } else {\n            uint LUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(lastLUSDLossError_Offset);\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" LUSD loss,\n            * which ensures the error in any given compoundedLUSDDeposit favors the Stability Pool.\n            */\n            LUSDLossPerUnitStaked = (LUSDLossNumerator.div(_totalLUSDDeposits)).add(1);\n            lastLUSDLossError_Offset = (LUSDLossPerUnitStaked.mul(_totalLUSDDeposits)).sub(LUSDLossNumerator);\n        }\n\n        ETHGainPerUnitStaked = ETHNumerator.div(_totalLUSDDeposits);\n        lastETHError_Offset = ETHNumerator.sub(ETHGainPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return (ETHGainPerUnitStaked, LUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(uint _ETHGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_LUSDLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool LUSD in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - LUSDLossPerUnitStaked)\n        */\n        uint newProductFactor = uint(DECIMAL_PRECISION).sub(_LUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The ETH gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to ETH gain, and P to deposit loss, we update S first.\n        */\n        uint marginalETHGain = _ETHGainPerUnitStaked.mul(currentP);\n        uint newS = currentS.add(marginalETHGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n        // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION); \n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\n        IActivePool activePoolCached = activePool;\n\n        // Cancel the liquidated LUSD debt with the LUSD in the stability pool\n        activePoolCached.decreaseLUSDDebt(_debtToOffset);\n        _decreaseLUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        lusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendETH(address(this), _collToAdd);\n    }\n\n    function _decreaseLUSD(uint _amount) internal {\n        uint newTotalLUSDDeposits = totalLUSDDeposits.sub(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit StabilityPoolLUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorETHGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint ETHGain = _getETHGainFromSnapshots(initialDeposit, snapshots);\n        return ETHGain;\n    }\n\n    function _getETHGainFromSnapshots(uint initialDeposit, Snapshots memory snapshots) internal view returns (uint) {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The ETH gain may span up to one scale change.\n        * If it does, the second portion of the ETH gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint S_Snapshot = snapshots.S;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(S_Snapshot);\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(SCALE_FACTOR);\n\n        uint ETHGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);\n\n        return ETHGain;\n    }\n\n    /*\n    * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n    * Given by the formula:  LQTY = d0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorLQTYGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {return 0;}\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /*\n        * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n        * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n        * which they made their deposit.\n        */\n        uint kickbackRate = frontEndTag == address(0) ? DECIMAL_PRECISION : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint LQTYGain = kickbackRate.mul(_getLQTYGainFromSnapshots(initialDeposit, snapshots)).div(DECIMAL_PRECISION);\n\n        return LQTYGain;\n    }\n\n    /*\n    * Return the LQTY gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    *\n    * D0 is the last recorded value of the front end's total tagged deposits.\n    */\n    function getFrontEndLQTYGain(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint frontEndShare = uint(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint LQTYGain = frontEndShare.mul(_getLQTYGainFromSnapshots(frontEndStake, snapshots)).div(DECIMAL_PRECISION);\n        return LQTYGain;\n    }\n\n    function _getLQTYGainFromSnapshots(uint initialStake, Snapshots memory snapshots) internal view returns (uint) {\n       /*\n        * Grab the sum 'G' from the epoch at which the stake was made. The LQTY gain may span up to one scale change.\n        * If it does, the second portion of the LQTY gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint G_Snapshot = snapshots.G;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(SCALE_FACTOR);\n\n        uint LQTYGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION); \n         \n        return LQTYGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedLUSDDeposit(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /*\n    * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken at the last time\n    * when one of the front end's tagged deposits updated their deposit.\n    *\n    * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n    */\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-9 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else { // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.\n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake.div(1e9)) {return 0;}\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for LUSD deposit, ETH gains and LQTY gains ---\n\n    // Transfer the LUSD tokens from the user to the Stability Pool's address, and update its recorded LUSD\n    function _sendLUSDtoStabilityPool(address _address, uint _amount) internal {\n        lusdToken.sendToPool(_address, address(this), _amount);\n        uint newTotalLUSDDeposits = totalLUSDDeposits.add(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit StabilityPoolLUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    function _sendETHGainToDepositor(uint _amount) internal {\n        if (_amount == 0) {return;}\n        uint newETH = ETH.sub(_amount);\n        ETH = newETH;\n        emit StabilityPoolETHBalanceUpdated(newETH);\n        emit EtherSent(msg.sender, _amount);\n\n        IERC20(stETHAddress).transfer(msg.sender, _amount);\n    }\n\n    // Send LUSD to user and decrease LUSD in Pool\n    function _sendLUSDToDepositor(address _depositor, uint LUSDWithdrawal) internal {\n        if (LUSDWithdrawal == 0) {return;}\n\n        lusdToken.returnFromPool(address(this), _depositor, LUSDWithdrawal);\n        _decreaseLUSD(LUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n\n    function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutLQTYGains(ICommunityIssuance _communityIssuance, address _depositor, address _frontEnd) internal {\n        // Pay out front end's LQTY gain\n        if (_frontEnd != address(0)) {\n            uint frontEndLQTYGain = getFrontEndLQTYGain(_frontEnd);\n            _communityIssuance.sendLQTY(_frontEnd, frontEndLQTYGain);\n            emit LQTYPaidToFrontEnd(_frontEnd, frontEndLQTYGain);\n        }\n\n        // Pay out depositor's LQTY gain\n        uint depositorLQTYGain = getDepositorLQTYGain(_depositor);\n        _communityIssuance.sendLQTY(_depositor, depositorLQTYGain);\n        emit LQTYPaidToDepositor(_depositor, depositorLQTYGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require( msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal {\n        uint price = priceFeed.fetchPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(ICR >= MCR, \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\");\n    }\n\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n        require(_initialDeposit > 0, 'StabilityPool: User must have a non-zero deposit');\n    }\n\n     function _requireUserHasNoDeposit(address _address) internal view {\n        uint initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, 'StabilityPool: User must have no deposit');\n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, 'StabilityPool: Amount must be non-zero');\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(troveManager.getTroveStatus(_depositor) == 1, \"StabilityPool: caller must have an active trove to withdraw ETHGain to\");\n    }\n\n    function _requireUserHasETHGain(address _depositor) internal view {\n        uint ETHGain = getDepositorETHGain(_depositor);\n        require(ETHGain > 0, \"StabilityPool: caller must have non-zero ETH Gain\");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(!frontEnds[_address].registered, \"StabilityPool: must not already be a registered front end\");\n    }\n\n     function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(frontEnds[_address].registered || _address == address(0),\n            \"StabilityPool: Tag must be a registered front end, or the zero address\");\n    }\n\n    function  _requireValidKickbackRate(uint _kickbackRate) internal pure {\n        require (_kickbackRate <= DECIMAL_PRECISION, \"StabilityPool: Kickback rate must be in range [0,1]\");\n    }\n\n    // --- Fallback function ---\n\n    // To Change\n    function addETH(uint amount) external override {\n        _requireCallerIsActivePool();\n        ETH = ETH.add(amount);\n        StabilityPoolETHBalanceUpdated(ETH);\n    }\n}\n","contract":"StabilityPool","function":"_requireUserHasDeposit","line":962,"range":[44168,44333]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,83,116,97,98,105,108,105,116,121,80,111,111,108,58,32,85,115,101,114,32,109,117,115,116,32,104,97,118,101,32,97,32,110,111,110,45,122,101,114,111,32,100,101,112,111,115,105,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003053746162696c697479506f6f6c3a2055736572206d75737420686176652061206e6f6e2d7a65726f206465706f73697400000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  16) EthersLiquity
       StabilityPool
         when people overstay
           "before all" hook for "should still be able to withdraw remaining deposit":
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0x30dD941929b2446eD899af59C8C1E07D5B6B2A68","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000010f0cf064dd5920000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b5e3af16b1880000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  17) EthersLiquity
       Redemption
         should fail to redeem during the bootstrap phase:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0xB1D6aE721167fe7E3fe59a21833352b540Fb4048","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000f95dd2ec27cce00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055de6a779bbac0000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  18) EthersLiquity
       Redemption
         should redeem some LUSD after the bootstrap phase:

      AssertionError: expected { Object (collateral, debt) } to deeply equal { Object (collateral, debt) }
      + expected - actual

       {
         "collateral": {
           "_bigNumber": {
      -      "_hex": "0x00"
      +      "_hex": "0x089e917994f71c0000"
             "_isBigNumber": true
           }
         }
         "debt": {
           "_bigNumber": {
      -      "_hex": "0x00"
      +      "_hex": "0x027d3674effd691a0000"
             "_isBigNumber": true
           }
         }
       }
      
      at Context.<anonymous> (test/Liquity.test.ts:725:29)

  19) EthersLiquity
       Redemption
         should claim the collateral surplus after redemption:

      AssertionError: expected '0' to equal '9.4475'
      + expected - actual

      -0
      +9.4475
      
      at Context.<anonymous> (test/Liquity.test.ts:770:32)

  20) EthersLiquity
       Redemption
         borrowing rate should be maxed out now:

      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment")

      + expected - actual

      -false
      +true
      
      at UserTrove.adjustTo (/Users/maytham/j/persistant.money/packages/lib-base/src/Trove.ts:710:11)
      at PopulatableEthersLiquity.adjustTrove (src/PopulatableEthersLiquity.ts:1000:63)
      at async Context.<anonymous> (test/Liquity.test.ts:803:33)

  21) EthersLiquity
       Redemption (truncation)
         "before each" hook for "should truncate the amount if it would put the last Trove below the min debt":
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0x62Fd30760D0395BaA9b69056527F5Fa4874C1f2d","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000010f0cf064dd59200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055de6a779bbac0000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  22) EthersLiquity
       Redemption (gas checks)
         "before all" hook for "should redeem using the maximum iterations and almost all gas":
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0xcB3E7F6BA9a335069935AC1Af5a5f28aC6B56d3B","to":"0x07634233DC0942194dB65262630A02A93566e264","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006c6b935b8bbd40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bc6f9956e3000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  23) EthersLiquity
       Hints (adjustTrove)
         "before all" hook for "should not use extra gas when a Trove's position doesn't change":
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0xcB3E7F6BA9a335069935AC1Af5a5f28aC6B56d3B","to":"0xF7e76507602Ab97421d830045aDa889e470439a1","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006c6b935b8bbd40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a055690d9db80000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  24) EthersLiquity
       Gas estimation
         "before all" hook for "should include enough gas for updating lastFeeOperationTime":
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x559D166ecC8155C8F91B65229D0E62596Ba71b88","to":"0x41913ad38610B8a31070D0C8115e3865c98A6F5b","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006e96afe79de4e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001158e460913d00000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  25) EthersLiquity
       Gas estimation (LQTY issuance)
         should include enough gas for issuing LQTY:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x2E7108e381e9ACab03aA1B4819aaCB50D2964532","to":"0x3aaA7aBE089fe1F0547E79274Fb40190063B5C7E","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000d8d726b7177a800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022b1c8c1227a00000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)

  26) EthersLiquity
       Gas estimation (fee decay)
         "before all" hook for "should predict the gas increase due to fee decay":
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'token balance or allowance is lower than amount requested'", method="estimateGas", transaction={"from":"0x559D166ecC8155C8F91B65229D0E62596Ba71b88","to":"0xeC08f52d10b80173F47C27b25f8D794e063E4388","data":"0x8e6b3ac5000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000006194049f30f720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001158e460913d00000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"function":"openTrove","contract":"BorrowerOperations","sourceName":"contracts/BorrowerOperations.sol","sourceContent":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public stETHAddress;\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress,\n        address _stETHAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n        checkContract(_stETHAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n        stETHAddress = _stETHAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    // To Change\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint, uint amount) external override {\n\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint, uint amount) external override {\n        IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint, uint amount) external override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0, amount);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage, 0);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint amount) external override {\n        if (amount != 0) {\n            IERC20(stETHAddress).transferFrom(msg.sender, address(this), amount);\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage, amount);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    // To Change\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage, uint amount) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, amount);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange, amount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && amount > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(amount, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    // To Change\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        IERC20(stETHAddress).transfer(address(_activePool), _amount);\n        _activePool.addETH(_amount);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    // To Change\n    function _requireSingularCollChange(uint _collWithdrawal, uint amount) internal pure {\n        require(amount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    // To Change\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange, uint amount) internal pure {\n        require(amount != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n","line":165,"range":[5600,5668]},"functionType":1},{"type":4,"sourceReference":{"function":"transferFrom","contract":"Token","sourceName":"contracts/Token.sol","sourceContent":"// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface IToken {\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance the balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value)  external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender  , uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Token is IToken {\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    uint256 public totalSupply;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value, \"token balance is lower than the value requested\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value, \"token balance or allowance is lower than amount requested\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) public {\n        balances[_to] = _value;\n    }\n\n    function hackApprove(address _from, address _spender, uint256 _value) public returns (bool success) {\n        allowed[_from][_spender] = _value;\n        emit Approval(_from, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n}","line":72,"range":[3829,3947]},"message":{"value":{"type":"Buffer","data":[8,195,121,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,116,111,107,101,110,32,98,97,108,97,110,99,101,32,111,114,32,97,108,108,111,119,97,110,99,101,32,105,115,32,108,111,119,101,114,32,116,104,97,110,32,97,109,111,117,110,116,32,114,101,113,117,101,115,116,101,100,0,0,0,0,0,0,0]},"_selector":"08c379a0"},"isInvalidOpcodeError":false}],"data":"0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000039746f6b656e2062616c616e6365206f7220616c6c6f77616e6365206973206c6f776572207468616e20616d6f756e742072657175657374656400000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (/Users/maytham/j/persistant.money/node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)



